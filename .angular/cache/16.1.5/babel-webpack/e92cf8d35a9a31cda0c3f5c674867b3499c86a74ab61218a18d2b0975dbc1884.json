{"ast":null,"code":"/**\n * @license Angular v16.1.6\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { Subject, Subscription, BehaviorSubject, Observable, merge as merge$1, of } from 'rxjs';\nimport { share, switchMap, distinctUntilChanged, first } from 'rxjs/operators';\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n      return key;\n    }\n  }\n  throw Error('Could not find renamed property on target object.');\n}\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nfunction fillProperties(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n  if (token == null) {\n    return '' + token;\n  }\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n  if (token.name) {\n    return `${token.name}`;\n  }\n  const res = token.toString();\n  if (res == null) {\n    return '' + res;\n  }\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nfunction concatStringsWithSpace(before, after) {\n  return before == null || before === '' ? after === null ? '' : after : after == null || after === '' ? before : before + ' ' + after;\n}\nconst __forward_ref__ = getClosureSafeProperty({\n  __forward_ref__: getClosureSafeProperty\n});\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * `forwardRef` is also used to break circularities in standalone components imports.\n *\n * @usageNotes\n * ### Circular dependency example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n *\n * ### Circular standalone reference import example\n * ```ts\n * @Component({\n *   standalone: true,\n *   imports: [ChildComponent],\n *   selector: 'app-parent',\n *   template: `<app-child [hideParent]=\"hideParent\"></app-child>`,\n * })\n * export class ParentComponent {\n *   @Input() hideParent: boolean;\n * }\n *\n *\n * @Component({\n *   standalone: true,\n *   imports: [CommonModule, forwardRef(() => ParentComponent)],\n *   selector: 'app-child',\n *   template: `<app-parent *ngIf=\"!hideParent\"></app-parent>`,\n * })\n * export class ChildComponent {\n *   @Input() hideParent: boolean;\n * }\n * ```\n *\n * @publicApi\n */\nfunction forwardRef(forwardRefFn) {\n  forwardRefFn.__forward_ref__ = forwardRef;\n  forwardRefFn.toString = function () {\n    return stringify(this());\n  };\n  return forwardRefFn;\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see {@link forwardRef}\n * @publicApi\n */\nfunction resolveForwardRef(type) {\n  return isForwardRef(type) ? type() : type;\n}\n/** Checks whether a function is wrapped by a `forwardRef`. */\nfunction isForwardRef(fn) {\n  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;\n}\nfunction isEnvironmentProviders(value) {\n  return value && !!value.ɵproviders;\n}\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n  constructor(code, message) {\n    super(formatRuntimeError(code, message));\n    this.code = code;\n  }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n  // Error code might be a negative number, which is a special marker that instructs the logic to\n  // generate a link to the error details page on angular.io.\n  // We also prepend `0` to non-compile-time errors.\n  const fullCode = `NG0${Math.abs(code)}`;\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nfunction renderStringify(value) {\n  if (typeof value === 'string') return value;\n  if (value == null) return '';\n  // Use `String` so that it invokes the `toString` method of the value. Note that this\n  // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n  return String(value);\n}\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nfunction stringifyForError(value) {\n  if (typeof value === 'function') return value.name || value.toString();\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n  return renderStringify(value);\n}\n\n/** Called when directives inject each other (creating a circular dependency) */\nfunction throwCyclicDependencyError(token, path) {\n  const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';\n  throw new RuntimeError(-200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */, `Circular dependency in DI detected for ${token}${depPath}`);\n}\nfunction throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n  } else if (isEnvironmentProviders(provider)) {\n    if (provider.ɵfromNgModule) {\n      throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n    } else {\n      throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);\n    }\n  } else {\n    throw new Error('Invalid provider');\n  }\n}\n/** Throws an error when a token is not found in DI. */\nfunction throwProviderNotFoundError(token, injectorName) {\n  const injectorDetails = injectorName ? ` in ${injectorName}` : '';\n  throw new RuntimeError(-201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */, ngDevMode && `No provider for ${stringifyForError(token)} found${injectorDetails}`);\n}\n\n// The functions in this file verify that the assumptions we are making\nfunction assertNumber(actual, msg) {\n  if (!(typeof actual === 'number')) {\n    throwError(msg, typeof actual, 'number', '===');\n  }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n  assertNumber(actual, 'Expected a number');\n  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\nfunction assertString(actual, msg) {\n  if (!(typeof actual === 'string')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n  }\n}\nfunction assertFunction(actual, msg) {\n  if (!(typeof actual === 'function')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n  }\n}\nfunction assertEqual(actual, expected, msg) {\n  if (!(actual == expected)) {\n    throwError(msg, actual, expected, '==');\n  }\n}\nfunction assertNotEqual(actual, expected, msg) {\n  if (!(actual != expected)) {\n    throwError(msg, actual, expected, '!=');\n  }\n}\nfunction assertSame(actual, expected, msg) {\n  if (!(actual === expected)) {\n    throwError(msg, actual, expected, '===');\n  }\n}\nfunction assertNotSame(actual, expected, msg) {\n  if (!(actual !== expected)) {\n    throwError(msg, actual, expected, '!==');\n  }\n}\nfunction assertLessThan(actual, expected, msg) {\n  if (!(actual < expected)) {\n    throwError(msg, actual, expected, '<');\n  }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n  if (!(actual <= expected)) {\n    throwError(msg, actual, expected, '<=');\n  }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n  if (!(actual > expected)) {\n    throwError(msg, actual, expected, '>');\n  }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n  if (!(actual >= expected)) {\n    throwError(msg, actual, expected, '>=');\n  }\n}\nfunction assertNotDefined(actual, msg) {\n  if (actual != null) {\n    throwError(msg, actual, null, '==');\n  }\n}\nfunction assertDefined(actual, msg) {\n  if (actual == null) {\n    throwError(msg, actual, null, '!=');\n  }\n}\nfunction throwError(msg, actual, expected, comparison) {\n  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n  if (!(node instanceof Node)) {\n    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n  }\n}\nfunction assertIndexInRange(arr, index) {\n  assertDefined(arr, 'Array must be defined.');\n  const maxLen = arr.length;\n  if (index < 0 || index >= maxLen) {\n    throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n  }\n}\nfunction assertOneOf(value, ...validValues) {\n  if (validValues.indexOf(value) !== -1) return true;\n  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\n\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call [`inject`](api/core/inject) to access the `Injector` and request injection\n * of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nfunction ɵɵdefineInjectable(opts) {\n  return {\n    token: opts.token,\n    providedIn: opts.providedIn || null,\n    factory: opts.factory,\n    value: undefined\n  };\n}\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use ɵɵdefineInjectable instead.\n * @publicApi\n */\nconst defineInjectable = ɵɵdefineInjectable;\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nfunction ɵɵdefineInjector(options) {\n  return {\n    providers: options.providers || [],\n    imports: options.imports || []\n  };\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\nfunction getInjectableDef(type) {\n  return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);\n}\nfunction isInjectable(type) {\n  return getInjectableDef(type) !== null;\n}\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition(type, field) {\n  return type.hasOwnProperty(field) ? type[field] : null;\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\n *\n * @param type A type which may have `ɵprov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `ɵprov` on an ancestor only.\n */\nfunction getInheritedInjectableDef(type) {\n  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);\n  if (def) {\n    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` + `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`);\n    return def;\n  } else {\n    return null;\n  }\n}\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`ɵinj`)\n */\nfunction getInjectorDef(type) {\n  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;\n}\nconst NG_PROV_DEF = getClosureSafeProperty({\n  ɵprov: getClosureSafeProperty\n});\nconst NG_INJ_DEF = getClosureSafeProperty({\n  ɵinj: getClosureSafeProperty\n});\n// We need to keep these around so we can read off old defs if new defs are unavailable\nconst NG_INJECTABLE_DEF = getClosureSafeProperty({\n  ngInjectableDef: getClosureSafeProperty\n});\nconst NG_INJECTOR_DEF = getClosureSafeProperty({\n  ngInjectorDef: getClosureSafeProperty\n});\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n * @deprecated use an options object for [`inject`](api/core/inject) instead.\n */\nvar InjectFlags;\n(function (InjectFlags) {\n  // TODO(alxhub): make this 'const' (and remove `InternalInjectFlags` enum) when ngc no longer\n  // writes exports of it into ngfactory files.\n  /** Check self and check parent injector if needed */\n  InjectFlags[InjectFlags[\"Default\"] = 0] = \"Default\";\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  InjectFlags[InjectFlags[\"Host\"] = 1] = \"Host\";\n  /** Don't ascend to ancestors of the node requesting injection. */\n  InjectFlags[InjectFlags[\"Self\"] = 2] = \"Self\";\n  /** Skip the node that is requesting injection. */\n  InjectFlags[InjectFlags[\"SkipSelf\"] = 4] = \"SkipSelf\";\n  /** Inject `defaultValue` instead if token not found. */\n  InjectFlags[InjectFlags[\"Optional\"] = 8] = \"Optional\";\n})(InjectFlags || (InjectFlags = {}));\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation;\nfunction getInjectImplementation() {\n  return _injectImplementation;\n}\n/**\n * Sets the current inject implementation.\n */\nfunction setInjectImplementation(impl) {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n  const injectableDef = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throwProviderNotFoundError(stringify(token), 'Injector');\n}\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nfunction assertInjectImplementationNotEqual(fn) {\n  ngDevMode && assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global = /* @__PURE__ */(() => typeof globalThis !== 'undefined' && globalThis || typeof global !== 'undefined' && global || typeof window !== 'undefined' && window || typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self)();\nfunction ngDevModeResetPerfCounters() {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0\n  };\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\nconst SOURCE = '__source';\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector = undefined;\nfunction getCurrentInjector() {\n  return _currentInjector;\n}\nfunction setCurrentInjector(injector) {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\nfunction injectInjectorOnly(token, flags = InjectFlags.Default) {\n  if (_currentInjector === undefined) {\n    throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode && `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\nfunction ɵɵinject(token, flags = InjectFlags.Default) {\n  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction ɵɵinvalidFactoryDep(index) {\n  throw new RuntimeError(202 /* RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY */, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported in a [injection context](/guide/dependency-injection-context). It can\n * be used during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n * - In a stackframe of a function call in a DI context\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```typescript\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```typescript\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```typescript\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nfunction inject(token, flags = InjectFlags.Default) {\n  return ɵɵinject(token, convertToBitFlags(flags));\n}\n// Converts object-based DI flags (`InjectOptions`) to bit flags (`InjectFlags`).\nfunction convertToBitFlags(flags) {\n  if (typeof flags === 'undefined' || typeof flags === 'number') {\n    return flags;\n  }\n  // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\n  // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\n  // `InjectOptions` to `InjectFlags`.\n  return 0 /* InternalInjectFlags.Default */ | (\n  // comment to force a line break in the formatter\n  flags.optional && 8 /* InternalInjectFlags.Optional */) | (flags.host && 1 /* InternalInjectFlags.Host */) | (flags.self && 2 /* InternalInjectFlags.Self */) | (flags.skipSelf && 4 /* InternalInjectFlags.SkipSelf */);\n}\n\nfunction injectArgs(types) {\n  const args = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode && 'Arguments array must have arguments.');\n      }\n      let type = undefined;\n      let flags = InjectFlags.Default;\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        const flag = getInjectFlag(meta);\n        if (typeof flag === 'number') {\n          // Special case when we handle @Inject decorator.\n          if (flag === -1 /* DecoratorFlags.Inject */) {\n            type = meta.token;\n          } else {\n            flags |= flag;\n          }\n        } else {\n          type = meta;\n        }\n      }\n      args.push(ɵɵinject(type, flags));\n    } else {\n      args.push(ɵɵinject(arg));\n    }\n  }\n  return args;\n}\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nfunction attachInjectFlag(decorator, flag) {\n  decorator[DI_DECORATOR_FLAG] = flag;\n  decorator.prototype[DI_DECORATOR_FLAG] = flag;\n  return decorator;\n}\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nfunction getInjectFlag(token) {\n  return token[DI_DECORATOR_FLAG];\n}\nfunction catchInjectorError(e, token, injectorErrorName, source) {\n  const tokenPath = e[NG_TEMP_TOKEN_PATH];\n  if (token[SOURCE]) {\n    tokenPath.unshift(token[SOURCE]);\n  }\n  e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n  e[NG_TOKEN_PATH] = tokenPath;\n  e[NG_TEMP_TOKEN_PATH] = null;\n  throw e;\n}\nfunction formatError(text, obj, injectorErrorName, source = null) {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n  let context = stringify(obj);\n  if (Array.isArray(obj)) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = [];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nfunction noSideEffects(fn) {\n  return {\n    toString: fn\n  }.toString();\n}\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n  /**\n   * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n   * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n   * Change detection can still be explicitly invoked.\n   * This strategy applies to all child directives and cannot be overridden.\n   */\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n  /**\n   * Use the default `CheckAlways` strategy, in which change detection is automatic until\n   * explicitly deactivated.\n   */\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\n\n/**\n * Defines the CSS styles encapsulation policies for the {@link Component} decorator's\n * `encapsulation` option.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nvar ViewEncapsulation$1;\n(function (ViewEncapsulation) {\n  // TODO: consider making `ViewEncapsulation` a `const enum` instead. See\n  // https://github.com/angular/angular/issues/44119 for additional information.\n  /**\n   * Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the\n   * component's host element and applying the same attribute to all the CSS selectors provided\n   * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls}.\n   *\n   * This is the default option.\n   */\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  /**\n   * Doesn't provide any sort of CSS style encapsulation, meaning that all the styles provided\n   * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls} are applicable\n   * to any HTML element of the application regardless of their host Component.\n   */\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  /**\n   * Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates\n   * a ShadowRoot for the component's host element which is then used to encapsulate\n   * all the Component's styling.\n   */\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = [];\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  // These property accesses can be ignored because ngDevMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_OBJ);\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_ARRAY);\n}\nconst NG_COMP_DEF = getClosureSafeProperty({\n  ɵcmp: getClosureSafeProperty\n});\nconst NG_DIR_DEF = getClosureSafeProperty({\n  ɵdir: getClosureSafeProperty\n});\nconst NG_PIPE_DEF = getClosureSafeProperty({\n  ɵpipe: getClosureSafeProperty\n});\nconst NG_MOD_DEF = getClosureSafeProperty({\n  ɵmod: getClosureSafeProperty\n});\nconst NG_FACTORY_DEF = getClosureSafeProperty({\n  ɵfac: getClosureSafeProperty\n});\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nconst NG_ELEMENT_ID = getClosureSafeProperty({\n  __NG_ELEMENT_ID__: getClosureSafeProperty\n});\n/**\n * The `NG_ENV_ID` field on a DI token indicates special processing in the `EnvironmentInjector`:\n * getting such tokens from the `EnvironmentInjector` will bypass the standard DI resolution\n * strategy and instead will return implementation produced by the `NG_ENV_ID` factory function.\n *\n * This particular retrieval of DI tokens is mostly done to eliminate circular dependencies and\n * improve tree-shaking.\n */\nconst NG_ENV_ID = getClosureSafeProperty({\n  __NG_ENV_ID__: getClosureSafeProperty\n});\n\n/**\n * Returns an index of `classToSearch` in `className` taking token boundaries into account.\n *\n * `classIndexOf('AB A', 'A', 0)` will be 3 (not 0 since `AB!==A`)\n *\n * @param className A string containing classes (whitespace separated)\n * @param classToSearch A class name to locate\n * @param startingIndex Starting location of search\n * @returns an index of the located class (or -1 if not found)\n */\nfunction classIndexOf(className, classToSearch, startingIndex) {\n  ngDevMode && assertNotEqual(classToSearch, '', 'can not look for \"\" string.');\n  let end = className.length;\n  while (true) {\n    const foundIndex = className.indexOf(classToSearch, startingIndex);\n    if (foundIndex === -1) return foundIndex;\n    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32 /* CharCode.SPACE */) {\n      // Ensure that it has leading whitespace\n      const length = classToSearch.length;\n      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32 /* CharCode.SPACE */) {\n        // Ensure that it has trailing whitespace\n        return foundIndex;\n      }\n    }\n    // False positive, keep searching from where we left off.\n    startingIndex = foundIndex + 1;\n  }\n}\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nfunction setUpAttributes(renderer, native, attrs) {\n  let i = 0;\n  while (i < attrs.length) {\n    const value = attrs[i];\n    if (typeof value === 'number') {\n      // only namespaces are supported. Other value types (such as style/class\n      // entries) are not supported in this function.\n      if (value !== 0 /* AttributeMarker.NamespaceURI */) {\n        break;\n      }\n      // we just landed on the marker value ... therefore\n      // we should skip to the next entry\n      i++;\n      const namespaceURI = attrs[i++];\n      const attrName = attrs[i++];\n      const attrVal = attrs[i++];\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      renderer.setAttribute(native, attrName, attrVal, namespaceURI);\n    } else {\n      // attrName is string;\n      const attrName = value;\n      const attrVal = attrs[++i];\n      // Standard attributes\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (isAnimationProp(attrName)) {\n        renderer.setProperty(native, attrName, attrVal);\n      } else {\n        renderer.setAttribute(native, attrName, attrVal);\n      }\n      i++;\n    }\n  }\n  // another piece of code may iterate over the same attributes array. Therefore\n  // it may be helpful to return the exact spot where the attributes array exited\n  // whether by running into an unsupported marker or if all the static values were\n  // iterated over.\n  return i;\n}\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nfunction isNameOnlyAttributeMarker(marker) {\n  return marker === 3 /* AttributeMarker.Bindings */ || marker === 4 /* AttributeMarker.Template */ || marker === 6 /* AttributeMarker.I18n */;\n}\n\nfunction isAnimationProp(name) {\n  // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n  // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n  // charCodeAt doesn't allocate memory to return a substring.\n  return name.charCodeAt(0) === 64 /* CharCode.AT_SIGN */;\n}\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\nfunction mergeHostAttrs(dst, src) {\n  if (src === null || src.length === 0) {\n    // do nothing\n  } else if (dst === null || dst.length === 0) {\n    // We have source, but dst is empty, just make a copy.\n    dst = src.slice();\n  } else {\n    let srcMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n    for (let i = 0; i < src.length; i++) {\n      const item = src[i];\n      if (typeof item === 'number') {\n        srcMarker = item;\n      } else {\n        if (srcMarker === 0 /* AttributeMarker.NamespaceURI */) {\n          // Case where we need to consume `key1`, `key2`, `value` items.\n        } else if (srcMarker === -1 /* AttributeMarker.ImplicitAttributes */ || srcMarker === 2 /* AttributeMarker.Styles */) {\n          // Case where we have to consume `key1` and `value` only.\n          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);\n        } else {\n          // Case where we have to consume `key1` only.\n          mergeHostAttribute(dst, srcMarker, item, null, null);\n        }\n      }\n    }\n  }\n  return dst;\n}\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\nfunction mergeHostAttribute(dst, marker, key1, key2, value) {\n  let i = 0;\n  // Assume that new markers will be inserted at the end.\n  let markerInsertPosition = dst.length;\n  // scan until correct type.\n  if (marker === -1 /* AttributeMarker.ImplicitAttributes */) {\n    markerInsertPosition = -1;\n  } else {\n    while (i < dst.length) {\n      const dstValue = dst[i++];\n      if (typeof dstValue === 'number') {\n        if (dstValue === marker) {\n          markerInsertPosition = -1;\n          break;\n        } else if (dstValue > marker) {\n          // We need to save this as we want the markers to be inserted in specific order.\n          markerInsertPosition = i - 1;\n          break;\n        }\n      }\n    }\n  }\n  // search until you find place of insertion\n  while (i < dst.length) {\n    const item = dst[i];\n    if (typeof item === 'number') {\n      // since `i` started as the index after the marker, we did not find it if we are at the next\n      // marker\n      break;\n    } else if (item === key1) {\n      // We already have same token\n      if (key2 === null) {\n        if (value !== null) {\n          dst[i + 1] = value;\n        }\n        return;\n      } else if (key2 === dst[i + 1]) {\n        dst[i + 2] = value;\n        return;\n      }\n    }\n    // Increment counter.\n    i++;\n    if (key2 !== null) i++;\n    if (value !== null) i++;\n  }\n  // insert at location.\n  if (markerInsertPosition !== -1) {\n    dst.splice(markerInsertPosition, 0, marker);\n    i = markerInsertPosition + 1;\n  }\n  dst.splice(i++, 0, key1);\n  if (key2 !== null) {\n    dst.splice(i++, 0, key2);\n  }\n  if (value !== null) {\n    dst.splice(i++, 0, value);\n  }\n}\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\nfunction isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {\n  // TODO(misko): The fact that this function needs to know about `isProjectionMode` seems suspect.\n  // It is strange to me that sometimes the class information comes in form of `class` attribute\n  // and sometimes in form of `AttributeMarker.Classes`. Some investigation is needed to determine\n  // if that is the right behavior.\n  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');\n  let i = 0;\n  // Indicates whether we are processing value from the implicit\n  // attribute section (i.e. before the first marker in the array).\n  let isImplicitAttrsSection = true;\n  while (i < attrs.length) {\n    let item = attrs[i++];\n    if (typeof item === 'string' && isImplicitAttrsSection) {\n      const value = attrs[i++];\n      if (isProjectionMode && item === 'class') {\n        // We found a `class` attribute in the implicit attribute section,\n        // check if it matches the value of the `cssClassToMatch` argument.\n        if (classIndexOf(value.toLowerCase(), cssClassToMatch, 0) !== -1) {\n          return true;\n        }\n      }\n    } else if (item === 1 /* AttributeMarker.Classes */) {\n      // We found the classes section. Start searching for the class.\n      while (i < attrs.length && typeof (item = attrs[i++]) == 'string') {\n        // while we have strings\n        if (item.toLowerCase() === cssClassToMatch) return true;\n      }\n      return false;\n    } else if (typeof item === 'number') {\n      // We've came across a first marker, which indicates\n      // that the implicit attribute section is over.\n      isImplicitAttrsSection = false;\n    }\n  }\n  return false;\n}\n/**\n * Checks whether the `tNode` represents an inline template (e.g. `*ngFor`).\n *\n * @param tNode current TNode\n */\nfunction isInlineTemplate(tNode) {\n  return tNode.type === 4 /* TNodeType.Container */ && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {\n  const tagNameToCompare = tNode.type === 4 /* TNodeType.Container */ && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n  return currentSelector === tagNameToCompare;\n}\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nfunction isNodeMatchingSelector(tNode, selector, isProjectionMode) {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n  let mode = 4 /* SelectorFlags.ELEMENT */;\n  const nodeAttrs = tNode.attrs || [];\n  // Find the index of first attribute that has no value, only a name.\n  const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = current | mode & 1 /* SelectorFlags.NOT */;\n      continue;\n    }\n    if (skipToNextSelector) continue;\n    if (mode & 4 /* SelectorFlags.ELEMENT */) {\n      mode = 2 /* SelectorFlags.ATTRIBUTE */ | mode & 1 /* SelectorFlags.NOT */;\n      if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === '' && selector.length === 1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const selectorAttrValue = mode & 8 /* SelectorFlags.CLASS */ ? current : selector[++i];\n      // special case for matching against classes when a tNode has been instantiated with\n      // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n      if (mode & 8 /* SelectorFlags.CLASS */ && tNode.attrs !== null) {\n        if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n        continue;\n      }\n      const attrName = mode & 8 /* SelectorFlags.CLASS */ ? 'class' : current;\n      const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue;\n        if (attrIndexInNode > nameOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0 /* AttributeMarker.NamespaceURI */, 'We do not match directives on namespaced attributes');\n          // we lowercase the attribute value to be able to match\n          // selectors without case-sensitivity\n          // (selectors are already in lowercase when generated)\n          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();\n        }\n        const compareAgainstClassName = mode & 8 /* SelectorFlags.CLASS */ ? nodeAttrValue : null;\n        if (compareAgainstClassName && classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 || mode & 2 /* SelectorFlags.ATTRIBUTE */ && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n  return isPositive(mode) || skipToNextSelector;\n}\nfunction isPositive(mode) {\n  return (mode & 1 /* SelectorFlags.NOT */) === 0;\n}\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {\n  if (attrs === null) return -1;\n  let i = 0;\n  if (isProjectionMode || !isInlineTemplate) {\n    let bindingsMode = false;\n    while (i < attrs.length) {\n      const maybeAttrName = attrs[i];\n      if (maybeAttrName === name) {\n        return i;\n      } else if (maybeAttrName === 3 /* AttributeMarker.Bindings */ || maybeAttrName === 6 /* AttributeMarker.I18n */) {\n        bindingsMode = true;\n      } else if (maybeAttrName === 1 /* AttributeMarker.Classes */ || maybeAttrName === 2 /* AttributeMarker.Styles */) {\n        let value = attrs[++i];\n        // We should skip classes here because we have a separate mechanism for\n        // matching classes in projection mode.\n        while (typeof value === 'string') {\n          value = attrs[++i];\n        }\n        continue;\n      } else if (maybeAttrName === 4 /* AttributeMarker.Template */) {\n        // We do not care about Template attributes in this scenario.\n        break;\n      } else if (maybeAttrName === 0 /* AttributeMarker.NamespaceURI */) {\n        // Skip the whole namespaced attribute and value. This is by design.\n        i += 4;\n        continue;\n      }\n      // In binding mode there are only names, rather than name-value pairs.\n      i += bindingsMode ? 1 : 2;\n    }\n    // We did not match the attribute\n    return -1;\n  } else {\n    return matchTemplateAttribute(attrs, name);\n  }\n}\nfunction isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getProjectAsAttrValue(tNode) {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(5 /* AttributeMarker.ProjectAs */);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1];\n    }\n  }\n  return null;\n}\nfunction getNameOnlyMarkerIndex(nodeAttrs) {\n  for (let i = 0; i < nodeAttrs.length; i++) {\n    const nodeAttr = nodeAttrs[i];\n    if (isNameOnlyAttributeMarker(nodeAttr)) {\n      return i;\n    }\n  }\n  return nodeAttrs.length;\n}\nfunction matchTemplateAttribute(attrs, name) {\n  let i = attrs.indexOf(4 /* AttributeMarker.Template */);\n  if (i > -1) {\n    i++;\n    while (i < attrs.length) {\n      const attr = attrs[i];\n      // Return in case we checked all template attrs and are switching to the next section in the\n      // attrs array (that starts with a number that represents an attribute marker).\n      if (typeof attr === 'number') return -1;\n      if (attr === name) return i;\n      i++;\n    }\n  }\n  return -1;\n}\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nfunction isSelectorInSelectorList(selector, list) {\n  selectorListLoop: for (let i = 0; i < list.length; i++) {\n    const currentSelectorInList = list[i];\n    if (selector.length !== currentSelectorInList.length) {\n      continue;\n    }\n    for (let j = 0; j < selector.length; j++) {\n      if (selector[j] !== currentSelectorInList[j]) {\n        continue selectorListLoop;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nfunction maybeWrapInNotSelector(isNegativeMode, chunk) {\n  return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\nfunction stringifyCSSSelector(selector) {\n  let result = selector[0];\n  let i = 1;\n  let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n  let currentChunk = '';\n  let isNegativeMode = false;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode & 2 /* SelectorFlags.ATTRIBUTE */) {\n        const attrValue = selector[++i];\n        currentChunk += '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n      } else if (mode & 8 /* SelectorFlags.CLASS */) {\n        currentChunk += '.' + valueOrMarker;\n      } else if (mode & 4 /* SelectorFlags.ELEMENT */) {\n        currentChunk += ' ' + valueOrMarker;\n      }\n    } else {\n      //\n      // Append current chunk to the final result in case we come across SelectorFlag, which\n      // indicates that the previous section of a selector is over. We need to accumulate content\n      // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n      // ```\n      //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n      // ```\n      // should be transformed to `.classA :not(.classB .classC)`.\n      //\n      // Note: for negative selector part, we accumulate content between flags until we find the\n      // next negative flag. This is needed to support a case where `:not()` rule contains more than\n      // one chunk, e.g. the following selector:\n      // ```\n      //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n      // ```\n      // should be stringified to `:not(p.foo) :not(.bar)`\n      //\n      if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n        currentChunk = '';\n      }\n      mode = valueOrMarker;\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector.\n      isNegativeMode = isNegativeMode || !isPositive(mode);\n    }\n    i++;\n  }\n  if (currentChunk !== '') {\n    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n  }\n  return result;\n}\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\nfunction stringifyCSSSelectorList(selectorList) {\n  return selectorList.map(stringifyCSSSelector).join(',');\n}\n/**\n * Extracts attributes and classes information from a given CSS selector.\n *\n * This function is used while creating a component dynamically. In this case, the host element\n * (that is created dynamically) should contain attributes and classes specified in component's CSS\n * selector.\n *\n * @param selector CSS selector in parsed form (in a form of array)\n * @returns object with `attrs` and `classes` fields that contain extracted information\n */\nfunction extractAttrsAndClassesFromSelector(selector) {\n  const attrs = [];\n  const classes = [];\n  let i = 1;\n  let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode === 2 /* SelectorFlags.ATTRIBUTE */) {\n        if (valueOrMarker !== '') {\n          attrs.push(valueOrMarker, selector[++i]);\n        }\n      } else if (mode === 8 /* SelectorFlags.CLASS */) {\n        classes.push(valueOrMarker);\n      }\n    } else {\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector. Since attributes and classes are\n      // extracted only for \"positive\" part of the selector, we can stop here.\n      if (!isPositive(mode)) break;\n      mode = valueOrMarker;\n    }\n    i++;\n  }\n  return {\n    attrs,\n    classes\n  };\n}\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyComponent {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nfunction ɵɵdefineComponent(componentDefinition) {\n  return noSideEffects(() => {\n    // Initialize ngDevMode. This must be the first statement in ɵɵdefineComponent.\n    // See the `initNgDevMode` docstring for more information.\n    (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n    const baseDef = getNgDirectiveDef(componentDefinition);\n    const def = {\n      ...baseDef,\n      decls: componentDefinition.decls,\n      vars: componentDefinition.vars,\n      template: componentDefinition.template,\n      consts: componentDefinition.consts || null,\n      ngContentSelectors: componentDefinition.ngContentSelectors,\n      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n      directiveDefs: null,\n      pipeDefs: null,\n      dependencies: baseDef.standalone && componentDefinition.dependencies || null,\n      getStandaloneInjector: null,\n      signals: componentDefinition.signals ?? false,\n      data: componentDefinition.data || {},\n      encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,\n      styles: componentDefinition.styles || EMPTY_ARRAY,\n      _: null,\n      schemas: componentDefinition.schemas || null,\n      tView: null,\n      id: ''\n    };\n    initFeatures(def);\n    const dependencies = componentDefinition.dependencies;\n    def.directiveDefs = extractDefListOrFactory(dependencies, /* pipeDef */false);\n    def.pipeDefs = extractDefListOrFactory(dependencies, /* pipeDef */true);\n    def.id = getComponentId(def);\n    return def;\n  });\n}\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nfunction ɵɵsetComponentScope(type, directives, pipes) {\n  const def = type.ɵcmp;\n  def.directiveDefs = extractDefListOrFactory(directives, /* pipeDef */false);\n  def.pipeDefs = extractDefListOrFactory(pipes, /* pipeDef */true);\n}\nfunction extractDirectiveDef(type) {\n  return getComponentDef(type) || getDirectiveDef(type);\n}\nfunction nonNull(value) {\n  return value !== null;\n}\n/**\n * @codeGenApi\n */\nfunction ɵɵdefineNgModule(def) {\n  return noSideEffects(() => {\n    const res = {\n      type: def.type,\n      bootstrap: def.bootstrap || EMPTY_ARRAY,\n      declarations: def.declarations || EMPTY_ARRAY,\n      imports: def.imports || EMPTY_ARRAY,\n      exports: def.exports || EMPTY_ARRAY,\n      transitiveCompileScopes: null,\n      schemas: def.schemas || null,\n      id: def.id || null\n    };\n    return res;\n  });\n}\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nfunction ɵɵsetNgModuleScope(type, scope) {\n  return noSideEffects(() => {\n    const ngModuleDef = getNgModuleDef(type, true);\n    ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n    ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n    ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n  });\n}\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject(obj, secondary) {\n  if (obj == null) return EMPTY_OBJ;\n  const newLookup = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      let publicName = obj[minifiedKey];\n      let declaredName = publicName;\n      if (Array.isArray(publicName)) {\n        declaredName = publicName[1];\n        publicName = publicName[0];\n      }\n      newLookup[publicName] = minifiedKey;\n      if (secondary) {\n        secondary[publicName] = declaredName;\n      }\n    }\n  }\n  return newLookup;\n}\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵdir = ɵɵdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵdefineDirective(directiveDefinition) {\n  return noSideEffects(() => {\n    const def = getNgDirectiveDef(directiveDefinition);\n    initFeatures(def);\n    return def;\n  });\n}\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ɵpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nfunction ɵɵdefinePipe(pipeDef) {\n  return {\n    type: pipeDef.type,\n    name: pipeDef.name,\n    factory: null,\n    pure: pipeDef.pure !== false,\n    standalone: pipeDef.standalone === true,\n    onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n  };\n}\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\nfunction getComponentDef(type) {\n  return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDef(type) {\n  return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef$1(type) {\n  return type[NG_PIPE_DEF] || null;\n}\n/**\n * Checks whether a given Component, Directive or Pipe is marked as standalone.\n * This will return false if passed anything other than a Component, Directive, or Pipe class\n * See [this guide](/guide/standalone-components) for additional information:\n *\n * @param type A reference to a Component, Directive or Pipe.\n * @publicApi\n */\nfunction isStandalone(type) {\n  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);\n  return def !== null ? def.standalone : false;\n}\nfunction getNgModuleDef(type, throwNotFound) {\n  const ngModuleDef = type[NG_MOD_DEF] || null;\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);\n  }\n  return ngModuleDef;\n}\nfunction getNgDirectiveDef(directiveDefinition) {\n  const declaredInputs = {};\n  return {\n    type: directiveDefinition.type,\n    providersResolver: null,\n    factory: null,\n    hostBindings: directiveDefinition.hostBindings || null,\n    hostVars: directiveDefinition.hostVars || 0,\n    hostAttrs: directiveDefinition.hostAttrs || null,\n    contentQueries: directiveDefinition.contentQueries || null,\n    declaredInputs,\n    inputTransforms: null,\n    inputConfig: directiveDefinition.inputs || EMPTY_OBJ,\n    exportAs: directiveDefinition.exportAs || null,\n    standalone: directiveDefinition.standalone === true,\n    signals: directiveDefinition.signals === true,\n    selectors: directiveDefinition.selectors || EMPTY_ARRAY,\n    viewQuery: directiveDefinition.viewQuery || null,\n    features: directiveDefinition.features || null,\n    setInput: null,\n    findHostDirectiveDefs: null,\n    hostDirectives: null,\n    inputs: invertObject(directiveDefinition.inputs, declaredInputs),\n    outputs: invertObject(directiveDefinition.outputs)\n  };\n}\nfunction initFeatures(definition) {\n  definition.features?.forEach(fn => fn(definition));\n}\nfunction extractDefListOrFactory(dependencies, pipeDef) {\n  if (!dependencies) {\n    return null;\n  }\n  const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;\n  return () => (typeof dependencies === 'function' ? dependencies() : dependencies).map(dep => defExtractor(dep)).filter(nonNull);\n}\n/**\n * A map that contains the generated component IDs and type.\n */\nconst GENERATED_COMP_IDS = new Map();\n/**\n * A method can returns a component ID from the component definition using a variant of DJB2 hash\n * algorithm.\n */\nfunction getComponentId(componentDef) {\n  let hash = 0;\n  // We cannot rely solely on the component selector as the same selector can be used in different\n  // modules.\n  //\n  // `componentDef.style` is not used, due to it causing inconsistencies. Ex: when server\n  // component styles has no sourcemaps and browsers do.\n  //\n  // Example:\n  // https://github.com/angular/components/blob/d9f82c8f95309e77a6d82fd574c65871e91354c2/src/material/core/option/option.ts#L248\n  // https://github.com/angular/components/blob/285f46dc2b4c5b127d356cb7c4714b221f03ce50/src/material/legacy-core/option/option.ts#L32\n  const hashSelectors = [componentDef.selectors, componentDef.ngContentSelectors, componentDef.hostVars, componentDef.hostAttrs, componentDef.consts, componentDef.vars, componentDef.decls, componentDef.encapsulation, componentDef.standalone, componentDef.signals, componentDef.exportAs, JSON.stringify(componentDef.inputs), JSON.stringify(componentDef.outputs),\n  // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not\n  // match in the server and browser bundles.\n  Object.getOwnPropertyNames(componentDef.type.prototype), !!componentDef.contentQueries, !!componentDef.viewQuery].join('|');\n  for (const char of hashSelectors) {\n    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;\n  }\n  // Force positive number hash.\n  // 2147483647 = equivalent of Integer.MAX_VALUE.\n  hash += 2147483647 + 1;\n  const compId = 'c' + hash;\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (GENERATED_COMP_IDS.has(compId)) {\n      const previousCompDefType = GENERATED_COMP_IDS.get(compId);\n      if (previousCompDefType !== componentDef.type) {\n        console.warn(formatRuntimeError(-912 /* RuntimeErrorCode.COMPONENT_ID_COLLISION */, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));\n      }\n    } else {\n      GENERATED_COMP_IDS.set(compId, componentDef.type);\n    }\n  }\n  return compId;\n}\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nconst HOST = 0;\nconst TVIEW = 1;\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst DESCENDANT_VIEWS_TO_REFRESH = 5;\nconst T_HOST = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR$1 = 9;\nconst ENVIRONMENT = 10;\nconst RENDERER = 11;\nconst CHILD_HEAD = 12;\nconst CHILD_TAIL = 13;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nconst DECLARATION_VIEW = 14;\nconst DECLARATION_COMPONENT_VIEW = 15;\nconst DECLARATION_LCONTAINER = 16;\nconst PREORDER_HOOK_FLAGS = 17;\nconst QUERIES = 18;\nconst ID = 19;\nconst EMBEDDED_VIEW_INJECTOR = 20;\nconst ON_DESTROY_HOOKS = 21;\nconst HYDRATION = 22;\nconst REACTIVE_TEMPLATE_CONSUMER = 23;\nconst REACTIVE_HOST_BINDING_CONSUMER = 24;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nconst HEADER_OFFSET = 25;\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$4 = 1;\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nconst TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\nconst HAS_TRANSPLANTED_VIEWS = 2;\n// PARENT, NEXT, DESCENDANT_VIEWS_TO_REFRESH are indices 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\nconst DEHYDRATED_VIEWS = 10;\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nconst CONTAINER_HEADER_OFFSET = 11;\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$3 = 1;\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLView(value) {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLContainer(value) {\n  return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n  return (tNode.flags & 4 /* TNodeFlags.hasContentQuery */) !== 0;\n}\nfunction isComponentHost(tNode) {\n  return tNode.componentOffset > -1;\n}\nfunction isDirectiveHost(tNode) {\n  return (tNode.flags & 1 /* TNodeFlags.isDirectiveHost */) === 1 /* TNodeFlags.isDirectiveHost */;\n}\n\nfunction isComponentDef(def) {\n  return !!def.template;\n}\nfunction isRootView(target) {\n  return (target[FLAGS] & 512 /* LViewFlags.IsRoot */) !== 0;\n}\nfunction isProjectionTNode(tNode) {\n  return (tNode.type & 16 /* TNodeType.Projection */) === 16 /* TNodeType.Projection */;\n}\n\nfunction hasI18n(lView) {\n  return (lView[FLAGS] & 32 /* LViewFlags.HasI18n */) === 32 /* LViewFlags.HasI18n */;\n}\n\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\nfunction assertTNodeForLView(tNode, lView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeForTView(tNode, tView) {\n  assertTNode(tNode);\n  const tData = tView.data;\n  for (let i = HEADER_OFFSET; i < tData.length; i++) {\n    if (tData[i] === tNode) {\n      return;\n    }\n  }\n  throwError('This TNode does not belong to this TView.');\n}\nfunction assertTNode(tNode) {\n  assertDefined(tNode, 'TNode must be defined');\n  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n    throwError('Not of type TNode, got: ' + tNode);\n  }\n}\nfunction assertTIcu(tIcu) {\n  assertDefined(tIcu, 'Expected TIcu to be defined');\n  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n    throwError('Object is not of TIcu type.');\n  }\n}\nfunction assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \\'ɵcmp\\' property.') {\n  if (!getComponentDef(actual)) {\n    throwError(msg);\n  }\n}\nfunction assertNgModuleType(actual, msg = 'Type passed in is not NgModuleType, it does not have \\'ɵmod\\' property.') {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\nfunction assertCurrentTNodeIsParent(isParent) {\n  assertEqual(isParent, true, 'currentTNode should be a parent');\n}\nfunction assertHasParent(tNode) {\n  assertDefined(tNode, 'currentTNode should exist!');\n  assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\nfunction assertLContainer(value) {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\nfunction assertLViewOrUndefined(value) {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\nfunction assertLView(value) {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n  assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n  assertEqual(tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');\n}\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nfunction assertDirectiveDef(obj) {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\nfunction assertIndexInDeclRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n  if (!(lower <= index && index < upper)) {\n    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n  }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || 'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\nfunction assertParentView(lView, errMessage) {\n  assertDefined(lView, errMessage || 'Component views should always have a parent view (component\\'s host view)');\n}\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nfunction assertNodeInjector(lView, injectorIndex) {\n  assertIndexInExpandoRange(lView, injectorIndex);\n  assertIndexInExpandoRange(lView, injectorIndex + 8 /* NodeInjectorOffset.PARENT */);\n  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */], 'injectorIndex should point to parent injector');\n}\nfunction getFactoryDef(type, throwNotFound) {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = Symbol('SIGNAL');\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @developerPreview\n */\nfunction isSignal(value) {\n  return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n/**\n * Converts `fn` into a marked signal function (where `isSignal(fn)` will be `true`), and\n * potentially add some set of extra properties (passed as an object record `extraApi`).\n */\nfunction createSignalFromFunction(node, fn, extraApi = {}) {\n  fn[SIGNAL] = node;\n  // Copy properties from `extraApi` to `fn` to complete the desired API of the `Signal`.\n  return Object.assign(fn, extraApi);\n}\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nfunction defaultEquals(a, b) {\n  // `Object.is` compares two values using identity semantics which is desired behavior for\n  // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n  // those don't represent objects (we want to make sure that 2 objects are always considered\n  // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n  // as objects (`typeof null === 'object'`).\n  return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * A `WeakRef`-compatible reference that fakes the API with a strong reference\n * internally.\n */\nclass LeakyRef {\n  constructor(ref) {\n    this.ref = ref;\n  }\n  deref() {\n    return this.ref;\n  }\n}\n// `WeakRef` is not always defined in every TS environment where Angular is compiled. Instead,\n// read it off of the global context if available.\n// tslint:disable-next-line: no-toplevel-property-access\nlet WeakRefImpl = _global['WeakRef'] ?? LeakyRef;\nfunction newWeakRef(value) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && WeakRefImpl === undefined) {\n    throw new Error(`Angular requires a browser which supports the 'WeakRef' API`);\n  }\n  return new WeakRefImpl(value);\n}\nfunction setAlternateWeakRefImpl(impl) {\n  // no-op since the alternate impl is included by default by the framework. Remove once internal\n  // migration is complete.\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * Counter tracking the next `ProducerId` or `ConsumerId`.\n */\nlet _nextReactiveId = 0;\n/**\n * Tracks the currently active reactive consumer (or `null` if there is no active\n * consumer).\n */\nlet activeConsumer = null;\n/**\n * Whether the graph is currently propagating change notifications.\n */\nlet inNotificationPhase = false;\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n/**\n * A node in the reactive graph.\n *\n * Nodes can be producers of reactive values, consumers of other reactive values, or both.\n *\n * Producers are nodes that produce values, and can be depended upon by consumer nodes.\n *\n * Producers expose a monotonic `valueVersion` counter, and are responsible for incrementing this\n * version when their value semantically changes. Some producers may produce their values lazily and\n * thus at times need to be polled for potential updates to their value (and by extension their\n * `valueVersion`). This is accomplished via the `onProducerUpdateValueVersion` method for\n * implemented by producers, which should perform whatever calculations are necessary to ensure\n * `valueVersion` is up to date.\n *\n * Consumers are nodes that depend on the values of producers and are notified when those values\n * might have changed.\n *\n * Consumers do not wrap the reads they consume themselves, but rather can be set as the active\n * reader via `setActiveConsumer`. Reads of producers that happen while a consumer is active will\n * result in those producers being added as dependencies of that consumer node.\n *\n * The set of dependencies of a consumer is dynamic. Implementers expose a monotonically increasing\n * `trackingVersion` counter, which increments whenever the consumer is about to re-run any reactive\n * reads it needs and establish a new set of dependencies as a result.\n *\n * Producers store the last `trackingVersion` they've seen from `Consumer`s which have read them.\n * This allows a producer to identify whether its record of the dependency is current or stale, by\n * comparing the consumer's `trackingVersion` to the version at which the dependency was\n * last observed.\n */\nclass ReactiveNode {\n  constructor() {\n    this.id = _nextReactiveId++;\n    /**\n     * A cached weak reference to this node, which will be used in `ReactiveEdge`s.\n     */\n    this.ref = newWeakRef(this);\n    /**\n     * Edges to producers on which this node depends (in its consumer capacity).\n     */\n    this.producers = new Map();\n    /**\n     * Edges to consumers on which this node depends (in its producer capacity).\n     */\n    this.consumers = new Map();\n    /**\n     * Monotonically increasing counter representing a version of this `Consumer`'s\n     * dependencies.\n     */\n    this.trackingVersion = 0;\n    /**\n     * Monotonically increasing counter which increases when the value of this `Producer`\n     * semantically changes.\n     */\n    this.valueVersion = 0;\n  }\n  /**\n   * Polls dependencies of a consumer to determine if they have actually changed.\n   *\n   * If this returns `false`, then even though the consumer may have previously been notified of a\n   * change, the values of its dependencies have not actually changed and the consumer should not\n   * rerun any reactions.\n   */\n  consumerPollProducersForChange() {\n    for (const [producerId, edge] of this.producers) {\n      const producer = edge.producerNode.deref();\n      // On Safari < 16.1 deref can return null, we need to check for null also.\n      // See https://github.com/WebKit/WebKit/commit/44c15ba58912faab38b534fef909dd9e13e095e0\n      if (producer == null || edge.atTrackingVersion !== this.trackingVersion) {\n        // This dependency edge is stale, so remove it.\n        this.producers.delete(producerId);\n        producer?.consumers.delete(this.id);\n        continue;\n      }\n      if (producer.producerPollStatus(edge.seenValueVersion)) {\n        // One of the dependencies reports a real value change.\n        return true;\n      }\n    }\n    // No dependency reported a real value change, so the `Consumer` has also not been\n    // impacted.\n    return false;\n  }\n  /**\n   * Notify all consumers of this producer that its value may have changed.\n   */\n  producerMayHaveChanged() {\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n      for (const [consumerId, edge] of this.consumers) {\n        const consumer = edge.consumerNode.deref();\n        // On Safari < 16.1 deref can return null, we need to check for null also.\n        // See https://github.com/WebKit/WebKit/commit/44c15ba58912faab38b534fef909dd9e13e095e0\n        if (consumer == null || consumer.trackingVersion !== edge.atTrackingVersion) {\n          this.consumers.delete(consumerId);\n          consumer?.producers.delete(this.id);\n          continue;\n        }\n        consumer.onConsumerDependencyMayHaveChanged();\n      }\n    } finally {\n      inNotificationPhase = prev;\n    }\n  }\n  /**\n   * Mark that this producer node has been accessed in the current reactive context.\n   */\n  producerAccessed() {\n    if (inNotificationPhase) {\n      throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n    }\n    if (activeConsumer === null) {\n      return;\n    }\n    // Either create or update the dependency `Edge` in both directions.\n    let edge = activeConsumer.producers.get(this.id);\n    if (edge === undefined) {\n      edge = {\n        consumerNode: activeConsumer.ref,\n        producerNode: this.ref,\n        seenValueVersion: this.valueVersion,\n        atTrackingVersion: activeConsumer.trackingVersion\n      };\n      activeConsumer.producers.set(this.id, edge);\n      this.consumers.set(activeConsumer.id, edge);\n    } else {\n      edge.seenValueVersion = this.valueVersion;\n      edge.atTrackingVersion = activeConsumer.trackingVersion;\n    }\n  }\n  /**\n   * Whether this consumer currently has any producers registered.\n   */\n  get hasProducers() {\n    return this.producers.size > 0;\n  }\n  /**\n   * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n   * based on the current consumer context.\n   */\n  get producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n  }\n  /**\n   * Checks if a `Producer` has a current value which is different than the value\n   * last seen at a specific version by a `Consumer` which recorded a dependency on\n   * this `Producer`.\n   */\n  producerPollStatus(lastSeenValueVersion) {\n    // `producer.valueVersion` may be stale, but a mismatch still means that the value\n    // last seen by the `Consumer` is also stale.\n    if (this.valueVersion !== lastSeenValueVersion) {\n      return true;\n    }\n    // Trigger the `Producer` to update its `valueVersion` if necessary.\n    this.onProducerUpdateValueVersion();\n    // At this point, we can trust `producer.valueVersion`.\n    return this.valueVersion !== lastSeenValueVersion;\n  }\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nfunction computed(computation, options) {\n  const node = new ComputedImpl(computation, options?.equal ?? defaultEquals);\n  // Casting here is required for g3, as TS inference behavior is slightly different between our\n  // version/options and g3's.\n  return createSignalFromFunction(node, node.signal.bind(node));\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = Symbol('ERRORED');\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\nclass ComputedImpl extends ReactiveNode {\n  constructor(computation, equal) {\n    super();\n    this.computation = computation;\n    this.equal = equal;\n    /**\n     * Current value of the computation.\n     *\n     * This can also be one of the special values `UNSET`, `COMPUTING`, or `ERRORED`.\n     */\n    this.value = UNSET;\n    /**\n     * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n     * be re-thrown.\n     */\n    this.error = null;\n    /**\n     * Flag indicating that the computation is currently stale, meaning that one of the\n     * dependencies has notified of a potential change.\n     *\n     * It's possible that no dependency has _actually_ changed, in which case the `stale`\n     * state can be resolved without recomputing the value.\n     */\n    this.stale = true;\n    this.consumerAllowSignalWrites = false;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    if (this.stale) {\n      // We've already notified consumers that this value has potentially changed.\n      return;\n    }\n    // Record that the currently cached value may be stale.\n    this.stale = true;\n    // Notify any consumers about the potential change.\n    this.producerMayHaveChanged();\n  }\n  onProducerUpdateValueVersion() {\n    if (!this.stale) {\n      // The current value and its version are already up to date.\n      return;\n    }\n    // The current value is stale. Check whether we need to produce a new one.\n    if (this.value !== UNSET && this.value !== COMPUTING && !this.consumerPollProducersForChange()) {\n      // Even though we were previously notified of a potential dependency update, all of\n      // our dependencies report that they have not actually changed in value, so we can\n      // resolve the stale state without needing to recompute the current value.\n      this.stale = false;\n      return;\n    }\n    // The current value is stale, and needs to be recomputed. It still may not change -\n    // that depends on whether the newly computed value is equal to the old.\n    this.recomputeValue();\n  }\n  recomputeValue() {\n    if (this.value === COMPUTING) {\n      // Our computation somehow led to a cyclic read of itself.\n      throw new Error('Detected cycle in computations.');\n    }\n    const oldValue = this.value;\n    this.value = COMPUTING;\n    // As we're re-running the computation, update our dependent tracking version number.\n    this.trackingVersion++;\n    const prevConsumer = setActiveConsumer(this);\n    let newValue;\n    try {\n      newValue = this.computation();\n    } catch (err) {\n      newValue = ERRORED;\n      this.error = err;\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n    this.stale = false;\n    if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && this.equal(oldValue, newValue)) {\n      // No change to `valueVersion` - old and new values are\n      // semantically equivalent.\n      this.value = oldValue;\n      return;\n    }\n    this.value = newValue;\n    this.valueVersion++;\n  }\n  signal() {\n    // Check if the value needs updating before returning it.\n    this.onProducerUpdateValueVersion();\n    // Record that someone looked at this signal.\n    this.producerAccessed();\n    if (this.value === ERRORED) {\n      throw this.error;\n    }\n    return this.value;\n  }\n}\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\nclass WritableSignalImpl extends ReactiveNode {\n  constructor(value, equal) {\n    super();\n    this.value = value;\n    this.equal = equal;\n    this.consumerAllowSignalWrites = false;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    // This never happens for writable signals as they're not consumers.\n  }\n  onProducerUpdateValueVersion() {\n    // Writable signal value versions are always up to date.\n  }\n  /**\n   * Directly update the value of the signal to a new value, which may or may not be\n   * equal to the previous.\n   *\n   * In the event that `newValue` is semantically equal to the current value, `set` is\n   * a no-op.\n   */\n  set(newValue) {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    if (!this.equal(this.value, newValue)) {\n      this.value = newValue;\n      this.valueVersion++;\n      this.producerMayHaveChanged();\n      postSignalSetFn?.();\n    }\n  }\n  /**\n   * Derive a new value for the signal from its current value using the `updater` function.\n   *\n   * This is equivalent to calling `set` on the result of running `updater` on the current\n   * value.\n   */\n  update(updater) {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    this.set(updater(this.value));\n  }\n  /**\n   * Calls `mutator` on the current value and assumes that it has been mutated.\n   */\n  mutate(mutator) {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    // Mutate bypasses equality checks as it's by definition changing the value.\n    mutator(this.value);\n    this.valueVersion++;\n    this.producerMayHaveChanged();\n    postSignalSetFn?.();\n  }\n  asReadonly() {\n    if (this.readonlySignal === undefined) {\n      this.readonlySignal = createSignalFromFunction(this, () => this.signal());\n    }\n    return this.readonlySignal;\n  }\n  signal() {\n    this.producerAccessed();\n    return this.value;\n  }\n}\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nfunction signal(initialValue, options) {\n  const signalNode = new WritableSignalImpl(initialValue, options?.equal ?? defaultEquals);\n  // Casting here is required for g3, as TS inference behavior is slightly different between our\n  // version/options and g3's.\n  const signalFn = createSignalFromFunction(signalNode, signalNode.signal.bind(signalNode), {\n    set: signalNode.set.bind(signalNode),\n    update: signalNode.update.bind(signalNode),\n    mutate: signalNode.mutate.bind(signalNode),\n    asReadonly: signalNode.asReadonly.bind(signalNode)\n  });\n  return signalFn;\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nconst NOOP_CLEANUP_FN = () => {};\n/**\n * Watches a reactive expression and allows it to be scheduled to re-run\n * when any dependencies notify of a change.\n *\n * `Watch` doesn't run reactive expressions itself, but relies on a consumer-\n * provided scheduling operation to coordinate calling `Watch.run()`.\n */\nclass Watch extends ReactiveNode {\n  constructor(watch, schedule, allowSignalWrites) {\n    super();\n    this.watch = watch;\n    this.schedule = schedule;\n    this.dirty = false;\n    this.cleanupFn = NOOP_CLEANUP_FN;\n    this.registerOnCleanup = cleanupFn => {\n      this.cleanupFn = cleanupFn;\n    };\n    this.consumerAllowSignalWrites = allowSignalWrites;\n  }\n  notify() {\n    if (!this.dirty) {\n      this.schedule(this);\n    }\n    this.dirty = true;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    this.notify();\n  }\n  onProducerUpdateValueVersion() {\n    // Watches are not producers.\n  }\n  /**\n   * Execute the reactive expression in the context of this `Watch` consumer.\n   *\n   * Should be called by the user scheduling algorithm when the provided\n   * `schedule` hook is called by `Watch`.\n   */\n  run() {\n    this.dirty = false;\n    if (this.trackingVersion !== 0 && !this.consumerPollProducersForChange()) {\n      return;\n    }\n    const prevConsumer = setActiveConsumer(this);\n    this.trackingVersion++;\n    try {\n      this.cleanupFn();\n      this.cleanupFn = NOOP_CLEANUP_FN;\n      this.watch(this.registerOnCleanup);\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  cleanup() {\n    this.cleanupFn();\n  }\n}\n\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see {@link OnChanges}\n *\n * @publicApi\n */\nclass SimpleChange {\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n  /**\n   * Check whether the new value is the first value assigned.\n   */\n  isFirstChange() {\n    return this.firstChange;\n  }\n}\n\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static ɵcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵNgOnChangesFeature() {\n  return NgOnChangesFeatureImpl;\n}\nfunction NgOnChangesFeatureImpl(definition) {\n  if (definition.type.prototype.ngOnChanges) {\n    definition.setInput = ngOnChangesSetInput;\n  }\n  return rememberChangeHistoryAndInvokeOnChangesHook;\n}\n// This option ensures that the ngOnChanges lifecycle hook will be inherited\n// from superclasses (in InheritDefinitionFeature).\n/** @nocollapse */\n// tslint:disable-next-line:no-toplevel-property-access\nɵɵNgOnChangesFeature.ngInherit = true;\n/**\n * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate\n * `ngOnChanges`.\n *\n * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are\n * found it invokes `ngOnChanges` on the component instance.\n *\n * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,\n *     it is guaranteed to be called with component instance.\n */\nfunction rememberChangeHistoryAndInvokeOnChangesHook() {\n  const simpleChangesStore = getSimpleChangesStore(this);\n  const current = simpleChangesStore?.current;\n  if (current) {\n    const previous = simpleChangesStore.previous;\n    if (previous === EMPTY_OBJ) {\n      simpleChangesStore.previous = current;\n    } else {\n      // New changes are copied to the previous store, so that we don't lose history for inputs\n      // which were not changed this time\n      for (let key in current) {\n        previous[key] = current[key];\n      }\n    }\n    simpleChangesStore.current = null;\n    this.ngOnChanges(current);\n  }\n}\nfunction ngOnChangesSetInput(instance, value, publicName, privateName) {\n  const declaredName = this.declaredInputs[publicName];\n  ngDevMode && assertString(declaredName, 'Name of input in ngOnChanges has to be a string');\n  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {\n    previous: EMPTY_OBJ,\n    current: null\n  });\n  const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n  const previous = simpleChangesStore.previous;\n  const previousChange = previous[declaredName];\n  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n  instance[privateName] = value;\n}\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\nfunction getSimpleChangesStore(instance) {\n  return instance[SIMPLE_CHANGES_STORE] || null;\n}\nfunction setSimpleChangesStore(instance, store) {\n  return instance[SIMPLE_CHANGES_STORE] = store;\n}\nlet profilerCallback = null;\n/**\n * Sets the callback function which will be invoked before and after performing certain actions at\n * runtime (for example, before and after running change detection).\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n */\nconst setProfiler = profiler => {\n  profilerCallback = profiler;\n};\n/**\n * Profiler function which wraps user code executed by the runtime.\n *\n * @param event ProfilerEvent corresponding to the execution context\n * @param instance component instance\n * @param hookOrListener lifecycle hook function or output listener. The value depends on the\n *  execution context\n * @returns\n */\nconst profiler = function (event, instance, hookOrListener) {\n  if (profilerCallback != null /* both `null` and `undefined` */) {\n    profilerCallback(event, instance, hookOrListener);\n  }\n};\nconst SVG_NAMESPACE = 'svg';\nconst MATH_ML_NAMESPACE = 'math';\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapRNode(value) {\n  while (Array.isArray(value)) {\n    value = value[HOST];\n  }\n  return value;\n}\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapLView(value) {\n  while (Array.isArray(value)) {\n    // This check is same as `isLView()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (typeof value[TYPE] === 'object') return value;\n    value = value[HOST];\n  }\n  return null;\n}\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nfunction getNativeByIndex(index, lView) {\n  ngDevMode && assertIndexInRange(lView, index);\n  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n  return unwrapRNode(lView[index]);\n}\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNode(tNode, lView) {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertIndexInRange(lView, tNode.index);\n  const node = unwrapRNode(lView[tNode.index]);\n  return node;\n}\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNodeOrNull(tNode, lView) {\n  const index = tNode === null ? -1 : tNode.index;\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const node = unwrapRNode(lView[index]);\n    return node;\n  }\n  return null;\n}\n// fixme(misko): The return Type should be `TNode|null`\nfunction getTNode(tView, index) {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n  const tNode = tView.data[index];\n  ngDevMode && tNode !== null && assertTNode(tNode);\n  return tNode;\n}\n/** Retrieves a value from any `LView` or `TData`. */\nfunction load(view, index) {\n  ngDevMode && assertIndexInRange(view, index);\n  return view[index];\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  ngDevMode && assertIndexInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\n/** Checks whether a given view is in creation mode */\nfunction isCreationMode(view) {\n  return (view[FLAGS] & 4 /* LViewFlags.CreationMode */) === 4 /* LViewFlags.CreationMode */;\n}\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nfunction viewAttachedToChangeDetector(view) {\n  return (view[FLAGS] & 128 /* LViewFlags.Attached */) === 128 /* LViewFlags.Attached */;\n}\n/** Returns a boolean for whether the view is attached to a container. */\nfunction viewAttachedToContainer(view) {\n  return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n  if (index === null || index === undefined) return null;\n  ngDevMode && assertIndexInRange(consts, index);\n  return consts[index];\n}\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nfunction resetPreOrderHookFlags(lView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\n/**\n * Adds the `RefreshView` flag from the lView and updates DESCENDANT_VIEWS_TO_REFRESH counters of\n * parents.\n */\nfunction markViewForRefresh(lView) {\n  if ((lView[FLAGS] & 1024 /* LViewFlags.RefreshView */) === 0) {\n    lView[FLAGS] |= 1024 /* LViewFlags.RefreshView */;\n    updateViewsToRefresh(lView, 1);\n  }\n}\n/**\n * Removes the `RefreshView` flag from the lView and updates DESCENDANT_VIEWS_TO_REFRESH counters of\n * parents.\n */\nfunction clearViewRefreshFlag(lView) {\n  if (lView[FLAGS] & 1024 /* LViewFlags.RefreshView */) {\n    lView[FLAGS] &= ~1024 /* LViewFlags.RefreshView */;\n    updateViewsToRefresh(lView, -1);\n  }\n}\n/**\n * Updates the `DESCENDANT_VIEWS_TO_REFRESH` counter on the parents of the `LView` as well as the\n * parents above that whose\n *  1. counter goes from 0 to 1, indicating that there is a new child that has a view to refresh\n *  or\n *  2. counter goes from 1 to 0, indicating there are no more descendant views to refresh\n */\nfunction updateViewsToRefresh(lView, amount) {\n  let parent = lView[PARENT];\n  if (parent === null) {\n    return;\n  }\n  parent[DESCENDANT_VIEWS_TO_REFRESH] += amount;\n  let viewOrContainer = parent;\n  parent = parent[PARENT];\n  while (parent !== null && (amount === 1 && viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH] === 1 || amount === -1 && viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH] === 0)) {\n    parent[DESCENDANT_VIEWS_TO_REFRESH] += amount;\n    viewOrContainer = parent;\n    parent = parent[PARENT];\n  }\n}\n/**\n * Stores a LView-specific destroy callback.\n */\nfunction storeLViewOnDestroy(lView, onDestroyCallback) {\n  if ((lView[FLAGS] & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */) {\n    throw new RuntimeError(911 /* RuntimeErrorCode.VIEW_ALREADY_DESTROYED */, ngDevMode && 'View has already been destroyed.');\n  }\n  if (lView[ON_DESTROY_HOOKS] === null) {\n    lView[ON_DESTROY_HOOKS] = [];\n  }\n  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\n}\n/**\n * Removes previously registered LView-specific destroy callback.\n */\nfunction removeLViewOnDestroy(lView, onDestroyCallback) {\n  if (lView[ON_DESTROY_HOOKS] === null) return;\n  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\n  if (destroyCBIdx !== -1) {\n    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\n  }\n}\nconst instructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true,\n  skipHydrationRootTNode: null\n};\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\nlet _isInCheckNoChangesMode = false;\n/**\n * Returns true if the instruction state stack is empty.\n *\n * Intended to be called from tests only (tree shaken otherwise).\n */\nfunction specOnlyIsInstructionStateEmpty() {\n  return instructionState.lFrame.parent === null;\n}\nfunction getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n  return instructionState.bindingsEnabled;\n}\n/**\n * Returns true if currently inside a skip hydration block.\n * @returns boolean\n */\nfunction isInSkipHydrationBlock$1() {\n  return instructionState.skipHydrationRootTNode !== null;\n}\n/**\n * Returns true if this is the root TNode of the skip hydration block.\n * @param tNode the current TNode\n * @returns boolean\n */\nfunction isSkipHydrationRootTNode(tNode) {\n  return instructionState.skipHydrationRootTNode === tNode;\n}\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵenableBindings() {\n  instructionState.bindingsEnabled = true;\n}\n/**\n * Sets a flag to specify that the TNode is in a skip hydration block.\n * @param tNode the current TNode\n */\nfunction enterSkipHydrationBlock(tNode) {\n  instructionState.skipHydrationRootTNode = tNode;\n}\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵdisableBindings() {\n  instructionState.bindingsEnabled = false;\n}\n/**\n * Clears the root skip hydration node when leaving a skip hydration block.\n */\nfunction leaveSkipHydrationBlock() {\n  instructionState.skipHydrationRootTNode = null;\n}\n/**\n * Return the current `LView`.\n */\nfunction getLView() {\n  return instructionState.lFrame.lView;\n}\n/**\n * Return the current `TView`.\n */\nfunction getTView() {\n  return instructionState.lFrame.tView;\n}\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nfunction ɵɵrestoreView(viewToRestore) {\n  instructionState.lFrame.contextLView = viewToRestore;\n  return viewToRestore[CONTEXT];\n}\n/**\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nfunction ɵɵresetView(value) {\n  instructionState.lFrame.contextLView = null;\n  return value;\n}\nfunction getCurrentTNode() {\n  let currentTNode = getCurrentTNodePlaceholderOk();\n  while (currentTNode !== null && currentTNode.type === 64 /* TNodeType.Placeholder */) {\n    currentTNode = currentTNode.parent;\n  }\n  return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n  return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n  const lFrame = instructionState.lFrame;\n  const currentTNode = lFrame.currentTNode;\n  return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n  const lFrame = instructionState.lFrame;\n  lFrame.currentTNode = tNode;\n  lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n  return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n  instructionState.lFrame.isParent = false;\n}\nfunction getContextLView() {\n  const contextLView = instructionState.lFrame.contextLView;\n  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n  return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _isInCheckNoChangesMode;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  _isInCheckNoChangesMode = mode;\n}\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nfunction getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n  return index;\n}\nfunction getBindingIndex() {\n  return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n  return instructionState.lFrame.bindingIndex = value;\n}\nfunction nextBindingIndex() {\n  return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\nfunction isInI18nBlock() {\n  return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock) {\n  instructionState.lFrame.inI18n = isInI18nBlock;\n}\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nfunction getCurrentDirectiveIndex() {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nfunction getCurrentDirectiveDef(tData) {\n  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n  return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n  instructionState.lFrame.currentQueryIndex = value;\n}\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView) {\n  const tView = lView[TVIEW];\n  // Return the declaration parent for embedded views\n  if (tView.type === 2 /* TViewType.Embedded */) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  }\n  // Components don't have `TView.declTNode` because each instance of component could be\n  // inserted in different location, hence `TView.declTNode` is meaningless.\n  // Falling back to `T_HOST` in case we cross component boundary.\n  if (tView.type === 1 /* TViewType.Component */) {\n    return lView[T_HOST];\n  }\n  // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n  return null;\n}\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nfunction enterDI(lView, tNode, flags) {\n  ngDevMode && assertLViewOrUndefined(lView);\n  if (flags & InjectFlags.SkipSelf) {\n    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n    let parentTNode = tNode;\n    let parentLView = lView;\n    while (true) {\n      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n      parentTNode = parentTNode.parent;\n      if (parentTNode === null && !(flags & InjectFlags.Host)) {\n        parentTNode = getDeclarationTNode(parentLView);\n        if (parentTNode === null) break;\n        // In this case, a parent exists and is definitely an element. So it will definitely\n        // have an existing lView as the declaration view, which is why we can assume it's defined.\n        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n        parentLView = parentLView[DECLARATION_VIEW];\n        // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n        // We want to skip those and look only at Elements and ElementContainers to ensure\n        // we're looking at true parent nodes, and not content or other types.\n        if (parentTNode.type & (2 /* TNodeType.Element */ | 8 /* TNodeType.ElementContainer */)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (parentTNode === null) {\n      // If we failed to find a parent TNode this means that we should use module injector.\n      return false;\n    } else {\n      tNode = parentTNode;\n      lView = parentLView;\n    }\n  }\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const lFrame = instructionState.lFrame = allocLFrame();\n  lFrame.currentTNode = tNode;\n  lFrame.lView = lView;\n  return true;\n}\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nfunction enterView(newView) {\n  ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  if (ngDevMode) {\n    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n  }\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n  newLFrame.currentTNode = tView.firstChild;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.contextLView = newView;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.inI18n = false;\n}\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\nfunction createLFrame(parent) {\n  const lFrame = {\n    currentTNode: null,\n    isParent: true,\n    lView: null,\n    tView: null,\n    selectedIndex: -1,\n    contextLView: null,\n    elementDepthCount: 0,\n    currentNamespace: null,\n    currentDirectiveIndex: -1,\n    bindingRootIndex: -1,\n    bindingIndex: -1,\n    currentQueryIndex: 0,\n    parent: parent,\n    child: null,\n    inI18n: false\n  };\n  parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n  return lFrame;\n}\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight() {\n  const oldLFrame = instructionState.lFrame;\n  instructionState.lFrame = oldLFrame.parent;\n  oldLFrame.currentTNode = null;\n  oldLFrame.lView = null;\n  return oldLFrame;\n}\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nconst leaveDI = leaveViewLight;\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nfunction leaveView() {\n  const oldLFrame = leaveViewLight();\n  oldLFrame.isParent = true;\n  oldLFrame.tView = null;\n  oldLFrame.selectedIndex = -1;\n  oldLFrame.contextLView = null;\n  oldLFrame.elementDepthCount = 0;\n  oldLFrame.currentDirectiveIndex = -1;\n  oldLFrame.currentNamespace = null;\n  oldLFrame.bindingRootIndex = -1;\n  oldLFrame.bindingIndex = -1;\n  oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);\n  return contextLView[CONTEXT];\n}\nfunction walkUpViews(nestingLevel, currentView) {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW];\n    nestingLevel--;\n  }\n  return currentView;\n}\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nfunction getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nfunction setSelectedIndex(index) {\n  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, 'Can\\'t set index passed end of LView');\n  instructionState.lFrame.selectedIndex = index;\n}\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nfunction getSelectedTNode() {\n  const lFrame = instructionState.lFrame;\n  return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceHTML() {\n  namespaceHTMLInternal();\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nfunction namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace$1() {\n  return instructionState.lFrame.currentNamespace;\n}\nlet _wasLastNodeCreated = true;\n/**\n * Retrieves a global flag that indicates whether the most recent DOM node\n * was created or hydrated.\n */\nfunction wasLastNodeCreated() {\n  return _wasLastNodeCreated;\n}\n/**\n * Sets a global flag to indicate whether the most recent DOM node\n * was created or hydrated.\n */\nfunction lastNodeWasCreated(flag) {\n  _wasLastNodeCreated = flag;\n}\n\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\nfunction registerPreOrderHooks(directiveIndex, directiveDef, tView) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const {\n    ngOnChanges,\n    ngOnInit,\n    ngDoCheck\n  } = directiveDef.type.prototype;\n  if (ngOnChanges) {\n    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);\n    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);\n    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);\n  }\n  if (ngOnInit) {\n    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);\n  }\n  if (ngDoCheck) {\n    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);\n    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);\n  }\n}\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\nfunction registerPostOrderHooks(tView, tNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  // It's necessary to loop through the directives at elementEnd() (rather than processing in\n  // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n  // hooks for projected components and directives must be called *before* their hosts.\n  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n    const directiveDef = tView.data[i];\n    ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');\n    const lifecycleHooks = directiveDef.type.prototype;\n    const {\n      ngAfterContentInit,\n      ngAfterContentChecked,\n      ngAfterViewInit,\n      ngAfterViewChecked,\n      ngOnDestroy\n    } = lifecycleHooks;\n    if (ngAfterContentInit) {\n      (tView.contentHooks ??= []).push(-i, ngAfterContentInit);\n    }\n    if (ngAfterContentChecked) {\n      (tView.contentHooks ??= []).push(i, ngAfterContentChecked);\n      (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);\n    }\n    if (ngAfterViewInit) {\n      (tView.viewHooks ??= []).push(-i, ngAfterViewInit);\n    }\n    if (ngAfterViewChecked) {\n      (tView.viewHooks ??= []).push(i, ngAfterViewChecked);\n      (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);\n    }\n    if (ngOnDestroy != null) {\n      (tView.destroyHooks ??= []).push(i, ngOnDestroy);\n    }\n  }\n}\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeCheckHooks(lView, hooks, nodeIndex) {\n  callHooks(lView, hooks, 3 /* InitPhaseState.InitPhaseCompleted */, nodeIndex);\n}\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {\n  ngDevMode && assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init pre-order hooks should not be called more than once');\n  if ((lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n    callHooks(lView, hooks, initPhase, nodeIndex);\n  }\n}\nfunction incrementInitPhaseFlags(lView, initPhase) {\n  ngDevMode && assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init hooks phase should not be incremented after all init hooks have been run.');\n  let flags = lView[FLAGS];\n  if ((flags & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n    flags &= 8191 /* LViewFlags.IndexWithinInitPhaseReset */;\n    flags += 1 /* LViewFlags.InitPhaseStateIncrementer */;\n    lView[FLAGS] = flags;\n  }\n}\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction callHooks(currentView, arr, initPhase, currentNodeIndex) {\n  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, 'Hooks should never be run when in check no changes mode.');\n  const startIndex = currentNodeIndex !== undefined ? currentView[PREORDER_HOOK_FLAGS] & 65535 /* PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask */ : 0;\n  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n  const max = arr.length - 1; // Stop the loop at length - 1, because we look for the hook at i + 1\n  let lastNodeIndexFound = 0;\n  for (let i = startIndex; i < max; i++) {\n    const hook = arr[i + 1];\n    if (typeof hook === 'number') {\n      lastNodeIndexFound = arr[i];\n      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n        break;\n      }\n    } else {\n      const isInitHook = arr[i] < 0;\n      if (isInitHook) {\n        currentView[PREORDER_HOOK_FLAGS] += 65536 /* PreOrderHookFlags.NumberOfInitHooksCalledIncrementer */;\n      }\n\n      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n        callHook(currentView, initPhase, arr, i);\n        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760 /* PreOrderHookFlags.NumberOfInitHooksCalledMask */) + i + 2;\n      }\n      i++;\n    }\n  }\n}\n/**\n * Executes a single lifecycle hook, making sure that:\n * - it is called in the non-reactive context;\n * - profiling data are registered.\n */\nfunction callHookInternal(directive, hook) {\n  profiler(4 /* ProfilerEvent.LifecycleHookStart */, directive, hook);\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    hook.call(directive);\n  } finally {\n    setActiveConsumer(prevConsumer);\n    profiler(5 /* ProfilerEvent.LifecycleHookEnd */, directive, hook);\n  }\n}\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\nfunction callHook(currentView, initPhase, arr, i) {\n  const isInitHook = arr[i] < 0;\n  const hook = arr[i + 1];\n  const directiveIndex = isInitHook ? -arr[i] : arr[i];\n  const directive = currentView[directiveIndex];\n  if (isInitHook) {\n    const indexWithintInitPhase = currentView[FLAGS] >> 13 /* LViewFlags.IndexWithinInitPhaseShift */;\n    // The init phase state must be always checked here as it may have been recursively updated.\n    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 /* PreOrderHookFlags.NumberOfInitHooksCalledShift */ && (currentView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n      currentView[FLAGS] += 8192 /* LViewFlags.IndexWithinInitPhaseIncrementer */;\n      callHookInternal(directive, hook);\n    }\n  } else {\n    callHookInternal(directive, hook);\n  }\n}\nconst NO_PARENT_INJECTOR = -1;\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n/**\n * Factory for creating instances of injectors in the NodeInjector.\n *\n * This factory is complicated by the fact that it can resolve `multi` factories as well.\n *\n * NOTE: Some of the fields are optional which means that this class has two hidden classes.\n * - One without `multi` support (most common)\n * - One with `multi` values, (rare).\n *\n * Since VMs can cache up to 4 inline hidden classes this is OK.\n *\n * - Single factory: Only `resolving` and `factory` is defined.\n * - `providers` factory: `componentProviders` is a number and `index = -1`.\n * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n */\nclass NodeInjectorFactory {\n  constructor(\n  /**\n   * Factory to invoke in order to create a new instance.\n   */\n  factory,\n  /**\n   * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n   */\n  isViewProvider, injectImplementation) {\n    this.factory = factory;\n    /**\n     * Marker set to true during factory invocation to see if we get into recursive loop.\n     * Recursive loop causes an error to be displayed.\n     */\n    this.resolving = false;\n    ngDevMode && assertDefined(factory, 'Factory not specified');\n    ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n    this.canSeeViewProviders = isViewProvider;\n    this.injectImpl = injectImplementation;\n  }\n}\nfunction isFactory(obj) {\n  return obj instanceof NodeInjectorFactory;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$2 = 1;\n\n/**\n * Converts `TNodeType` into human readable text.\n * Make sure this matches with `TNodeType`\n */\nfunction toTNodeTypeAsString(tNodeType) {\n  let text = '';\n  tNodeType & 1 /* TNodeType.Text */ && (text += '|Text');\n  tNodeType & 2 /* TNodeType.Element */ && (text += '|Element');\n  tNodeType & 4 /* TNodeType.Container */ && (text += '|Container');\n  tNodeType & 8 /* TNodeType.ElementContainer */ && (text += '|ElementContainer');\n  tNodeType & 16 /* TNodeType.Projection */ && (text += '|Projection');\n  tNodeType & 32 /* TNodeType.Icu */ && (text += '|IcuContainer');\n  tNodeType & 64 /* TNodeType.Placeholder */ && (text += '|Placeholder');\n  return text.length > 0 ? text.substring(1) : text;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$1 = 1;\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasClassInput(tNode) {\n  return (tNode.flags & 8 /* TNodeFlags.hasClassInput */) !== 0;\n}\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasStyleInput(tNode) {\n  return (tNode.flags & 16 /* TNodeFlags.hasStyleInput */) !== 0;\n}\nfunction assertTNodeType(tNode, expectedTypes, message) {\n  assertDefined(tNode, 'should be called with a TNode');\n  if ((tNode.type & expectedTypes) === 0) {\n    throwError(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);\n  }\n}\nfunction assertPureTNodeType(type) {\n  if (!(type === 2 /* TNodeType.Element */ ||\n  //\n  type === 1 /* TNodeType.Text */ ||\n  //\n  type === 4 /* TNodeType.Container */ ||\n  //\n  type === 8 /* TNodeType.ElementContainer */ ||\n  //\n  type === 32 /* TNodeType.Icu */ ||\n  //\n  type === 16 /* TNodeType.Projection */ ||\n  //\n  type === 64 /* TNodeType.Placeholder */)) {\n    throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);\n  }\n}\n\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\nfunction hasParentInjector(parentLocation) {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\nfunction getParentInjectorIndex(parentLocation) {\n  ngDevMode && assertNumber(parentLocation, 'Number expected');\n  ngDevMode && assertNotEqual(parentLocation, -1, 'Not a valid state.');\n  const parentInjectorIndex = parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n  ngDevMode && assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');\n  return parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n}\n\nfunction getParentInjectorViewOffset(parentLocation) {\n  return parentLocation >> 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */;\n}\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nfunction getParentInjectorView(location, startView) {\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView;\n  // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW];\n    viewOffset--;\n  }\n  return parentView;\n}\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\nfunction setIncludeViewProviders(v) {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n/**\n * The number of bits that is represented by a single bloom bucket. JS bit operations are 32 bits,\n * so each bucket represents 32 distinct tokens which accounts for log2(32) = 5 bits of a bloom hash\n * number.\n */\nconst BLOOM_BUCKET_BITS = 5;\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n/** Value used when something wasn't found by an injector. */\nconst NOT_FOUND = {};\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nfunction bloomAdd(injectorIndex, tView, type) {\n  ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n  let id;\n  if (typeof type === 'string') {\n    id = type.charCodeAt(0) || 0;\n  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n    id = type[NG_ELEMENT_ID];\n  }\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = type[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomHash = id & BLOOM_MASK;\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  // Each bloom bucket in `tData` represents `BLOOM_BUCKET_BITS` number of bits of `bloomHash`.\n  // Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset that the mask\n  // should be written to.\n  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;\n}\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param lView View where the node is stored\n * @returns Node injector\n */\nfunction getOrCreateNodeInjectorForNode(tNode, lView) {\n  const existingInjectorIndex = getInjectorIndex(tNode, lView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n  const tView = lView[TVIEW];\n  if (tView.firstCreatePass) {\n    tNode.injectorIndex = lView.length;\n    insertBloom(tView.data, tNode); // foundation for node bloom\n    insertBloom(lView, null); // foundation for cumulative bloom\n    insertBloom(tView.blueprint, null);\n  }\n  const parentLoc = getParentInjectorLocation(tNode, lView);\n  const injectorIndex = tNode.injectorIndex;\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (hasParentInjector(parentLoc)) {\n    const parentIndex = getParentInjectorIndex(parentLoc);\n    const parentLView = getParentInjectorView(parentLoc, lView);\n    const parentData = parentLView[TVIEW].data;\n    // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n    for (let i = 0; i < 8 /* NodeInjectorOffset.BLOOM_SIZE */; i++) {\n      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n  lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */] = parentLoc;\n  return injectorIndex;\n}\nfunction insertBloom(arr, footer) {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\nfunction getInjectorIndex(tNode, lView) {\n  if (tNode.injectorIndex === -1 ||\n  // If the injector index is the same as its parent's injector index, then the index has been\n  // copied down from the parent node. No injector has been created yet on this node.\n  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex ||\n  // After the first template pass, the injector index might exist but the parent values\n  // might not have been calculated yet for this instance\n  lView[tNode.injectorIndex + 8 /* NodeInjectorOffset.PARENT */] === null) {\n    return -1;\n  } else {\n    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n    return tNode.injectorIndex;\n  }\n}\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * @returns Returns a number that is the combination of the number of LViews that we have to go up\n * to find the LView containing the parent inject AND the index of the injector within that LView.\n */\nfunction getParentInjectorLocation(tNode, lView) {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    // If we have a parent `TNode` and there is an injector associated with it we are done, because\n    // the parent injector is within the current `LView`.\n    return tNode.parent.injectorIndex; // ViewOffset is 0\n  }\n  // When parent injector location is computed it may be outside of the current view. (ie it could\n  // be pointing to a declared parent location). This variable stores number of declaration parents\n  // we need to walk up in order to find the parent injector location.\n  let declarationViewOffset = 0;\n  let parentTNode = null;\n  let lViewCursor = lView;\n  // The parent injector is not in the current `LView`. We will have to walk the declared parent\n  // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent\n  // `NodeInjector`.\n  while (lViewCursor !== null) {\n    parentTNode = getTNodeFromLView(lViewCursor);\n    if (parentTNode === null) {\n      // If we have no parent, than we are done.\n      return NO_PARENT_INJECTOR;\n    }\n    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);\n    // Every iteration of the loop requires that we go to the declared parent.\n    declarationViewOffset++;\n    lViewCursor = lViewCursor[DECLARATION_VIEW];\n    if (parentTNode.injectorIndex !== -1) {\n      // We found a NodeInjector which points to something.\n      return parentTNode.injectorIndex | declarationViewOffset << 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */;\n    }\n  }\n\n  return NO_PARENT_INJECTOR;\n}\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nfunction diPublicInInjector(injectorIndex, tView, token) {\n  bloomAdd(injectorIndex, tView, token);\n}\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ɵcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nfunction injectAttributeImpl(tNode, attrNameToInject) {\n  ngDevMode && assertTNodeType(tNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  if (attrNameToInject === 'class') {\n    return tNode.classes;\n  }\n  if (attrNameToInject === 'style') {\n    return tNode.styles;\n  }\n  const attrs = tNode.attrs;\n  if (attrs) {\n    const attrsLength = attrs.length;\n    let i = 0;\n    while (i < attrsLength) {\n      const value = attrs[i];\n      // If we hit a `Bindings` or `Template` marker then we are done.\n      if (isNameOnlyAttributeMarker(value)) break;\n      // Skip namespaced attributes\n      if (value === 0 /* AttributeMarker.NamespaceURI */) {\n        // we skip the next two values\n        // as namespaced attributes looks like\n        // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n        // 'existValue', ...]\n        i = i + 2;\n      } else if (typeof value === 'number') {\n        // Skip to the first value of the marked attribute.\n        i++;\n        while (i < attrsLength && typeof attrs[i] === 'string') {\n          i++;\n        }\n      } else if (value === attrNameToInject) {\n        return attrs[i + 1];\n      } else {\n        i = i + 2;\n      }\n    }\n  }\n  return null;\n}\nfunction notFoundValueOrThrow(notFoundValue, token, flags) {\n  if (flags & InjectFlags.Optional || notFoundValue !== undefined) {\n    return notFoundValue;\n  } else {\n    throwProviderNotFoundError(token, 'NodeInjector');\n  }\n}\n/**\n * Returns the value associated to the given token from the ModuleInjector or throws exception\n *\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector or throws an exception\n */\nfunction lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {\n  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR$1];\n    // switch to `injectInjectorOnly` implementation for module injector, since module injector\n    // should not have access to Component/Directive DI scope (that may happen through\n    // `directiveInject` implementation)\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      if (moduleInjector) {\n        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n      } else {\n        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n  return notFoundValueOrThrow(notFoundValue, token, flags);\n}\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {\n  if (tNode !== null) {\n    // If the view or any of its ancestors have an embedded\n    // view injector, we have to look it up there first.\n    if (lView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */ &&\n    // The token must be present on the current node injector when the `Self`\n    // flag is set, so the lookup on embedded view injector(s) can be skipped.\n    !(flags & InjectFlags.Self)) {\n      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);\n      if (embeddedInjectorValue !== NOT_FOUND) {\n        return embeddedInjectorValue;\n      }\n    }\n    // Otherwise try the node injector.\n    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);\n    if (value !== NOT_FOUND) {\n      return value;\n    }\n  }\n  // Finally, fall back to the module injector.\n  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n}\n/**\n * Returns the value associated to the given token from the node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {\n  const bloomHash = bloomHashBitOrFactory(token);\n  // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n  // so just call the factory function to create it.\n  if (typeof bloomHash === 'function') {\n    if (!enterDI(lView, tNode, flags)) {\n      // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n      // flag, the module injector is not searched for that token in Ivy.\n      return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n    }\n    try {\n      const value = bloomHash(flags);\n      if (value == null && !(flags & InjectFlags.Optional)) {\n        throwProviderNotFoundError(token);\n      } else {\n        return value;\n      }\n    } finally {\n      leaveDI();\n    }\n  } else if (typeof bloomHash === 'number') {\n    // A reference to the previous injector TView that was found while climbing the element\n    // injector tree. This is used to know if viewProviders can be accessed on the current\n    // injector.\n    let previousTView = null;\n    let injectorIndex = getInjectorIndex(tNode, lView);\n    let parentLocation = NO_PARENT_INJECTOR;\n    let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n    // If we should skip this injector, or if there is no injector on this node, start by\n    // searching the parent injector.\n    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n        injectorIndex = -1;\n      } else {\n        previousTView = lView[TVIEW];\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      }\n    }\n    // Traverse up the injector tree until we find a potential match or until we know there\n    // *isn't* a match.\n    while (injectorIndex !== -1) {\n      ngDevMode && assertNodeInjector(lView, injectorIndex);\n      // Check the current injector. If it matches, see if it contains token.\n      const tView = lView[TVIEW];\n      ngDevMode && assertTNodeForLView(tView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */], lView);\n      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n        // At this point, we have an injector which *may* contain the token, so we step through\n        // the providers and directives associated with the injector's corresponding node to get\n        // the instance.\n        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n        if (instance !== NOT_FOUND) {\n          return instance;\n        }\n      }\n      parentLocation = lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {\n        // The def wasn't found anywhere on this node, so it was a false positive.\n        // Traverse up the tree and continue searching.\n        previousTView = tView;\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      } else {\n        // If we should not search parent OR If the ancestor bloom filter value does not have the\n        // bit corresponding to the directive we can give up on traversing up to find the specific\n        // injector.\n        injectorIndex = -1;\n      }\n    }\n  }\n  return notFoundValue;\n}\nfunction searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n  // First, we need to determine if view providers can be accessed by the starting element.\n  // There are two possibilities\n  const canAccessViewProviders = previousTView == null ?\n  // 1) This is the first invocation `previousTView == null` which means that we are at the\n  // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n  // to look into the ViewProviders is if:\n  // - we are on a component\n  // - AND the injector set `includeViewProviders` to true (implying that the token can see\n  // ViewProviders because it is the Component or a Service which itself was declared in\n  // ViewProviders)\n  isComponentHost(tNode) && includeViewProviders :\n  // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n  // In such a case we are only allowed to look into the ViewProviders if:\n  // - We just crossed from child View to Parent View `previousTView != currentTView`\n  // - AND the parent TNode is an Element.\n  // This means that we just came from the Component's View and therefore are allowed to see\n  // into the ViewProviders.\n  previousTView != currentTView && (tNode.type & 3 /* TNodeType.AnyRNode */) !== 0;\n  // This special case happens when there is a @host on the inject and when we are searching\n  // on the host element node.\n  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;\n  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n  if (injectableIdx !== null) {\n    return getNodeInjectable(lView, currentTView, injectableIdx, tNode);\n  } else {\n    return NOT_FOUND;\n  }\n}\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nfunction locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n  const injectablesStart = nodeProviderIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount = nodeProviderIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n  // When the host special case applies, only the viewProviders and the component are visible\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef = tInjectables[i];\n    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {\n      return i;\n    }\n  }\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart];\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n  return null;\n}\n/**\n * Retrieve or instantiate the injectable from the `LView` at particular `index`.\n *\n * This function checks to see if the value has already been instantiated and if so returns the\n * cached `injectable`. Otherwise if it detects that the value is still a factory it\n * instantiates the `injectable` and caches the value.\n */\nfunction getNodeInjectable(lView, tView, index, tNode) {\n  let value = lView[index];\n  const tData = tView.data;\n  if (isFactory(value)) {\n    const factory = value;\n    if (factory.resolving) {\n      throwCyclicDependencyError(stringifyForError(tData[index]));\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;\n    const success = enterDI(lView, tNode, InjectFlags.Default);\n    ngDevMode && assertEqual(success, true, 'Because flags do not contain \\`SkipSelf\\' we expect this to always succeed.');\n    try {\n      value = lView[index] = factory.factory(undefined, tData, lView, tNode);\n      // This code path is hit for both directives and providers.\n      // For perf reasons, we want to avoid searching for hooks on providers.\n      // It does no harm to try (the hooks just won't exist), but the extra\n      // checks are unnecessary and this is a hot path. So we check to see\n      // if the index of the dependency is in the directive range for this\n      // tNode. If it's not, we know it's a provider and skip hook registration.\n      if (tView.firstCreatePass && index >= tNode.directiveStart) {\n        ngDevMode && assertDirectiveDef(tData[index]);\n        registerPreOrderHooks(index, tData[index], tView);\n      }\n    } finally {\n      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      leaveDI();\n    }\n  }\n  return value;\n}\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nfunction bloomHashBitOrFactory(token) {\n  ngDevMode && assertDefined(token, 'token must be defined');\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId =\n  // First check with `hasOwnProperty` so we don't get an inherited ID.\n  token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : undefined;\n  // Negative token IDs are used for special objects such as `Injector`\n  if (typeof tokenId === 'number') {\n    if (tokenId >= 0) {\n      return tokenId & BLOOM_MASK;\n    } else {\n      ngDevMode && assertEqual(tokenId, -1 /* InjectorMarkers.Injector */, 'Expecting to get Special Injector Id');\n      return createNodeInjector;\n    }\n  } else {\n    return tokenId;\n  }\n}\nfunction bloomHasToken(bloomHash, injectorIndex, injectorView) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  // Each bloom bucket in `injectorView` represents `BLOOM_BUCKET_BITS` number of bits of\n  // `bloomHash`. Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset\n  // that should be used.\n  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags, isFirstHostTNode) {\n  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\nclass NodeInjector {\n  constructor(_tNode, _lView) {\n    this._tNode = _tNode;\n    this._lView = _lView;\n  }\n  get(token, notFoundValue, flags) {\n    return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);\n  }\n}\n/** Creates a `NodeInjector` for the current node. */\nfunction createNodeInjector() {\n  return new NodeInjector(getCurrentTNode(), getLView());\n}\n/**\n * @codeGenApi\n */\nfunction ɵɵgetInheritedFactory(type) {\n  return noSideEffects(() => {\n    const ownConstructor = type.prototype.constructor;\n    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);\n    const objectPrototype = Object.prototype;\n    let parent = Object.getPrototypeOf(type.prototype).constructor;\n    // Go up the prototype until we hit `Object`.\n    while (parent && parent !== objectPrototype) {\n      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);\n      // If we hit something that has a factory and the factory isn't the same as the type,\n      // we've found the inherited factory. Note the check that the factory isn't the type's\n      // own factory is redundant in most cases, but if the user has custom decorators on the\n      // class, this lookup will start one level down in the prototype chain, causing us to\n      // find the own factory first and potentially triggering an infinite loop downstream.\n      if (factory && factory !== ownFactory) {\n        return factory;\n      }\n      parent = Object.getPrototypeOf(parent);\n    }\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return t => new t();\n  });\n}\nfunction getFactoryOf(type) {\n  if (isForwardRef(type)) {\n    return () => {\n      const factory = getFactoryOf(resolveForwardRef(type));\n      return factory && factory();\n    };\n  }\n  return getFactoryDef(type);\n}\n/**\n * Returns a value from the closest embedded or node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {\n  let currentTNode = tNode;\n  let currentLView = lView;\n  // When an LView with an embedded view injector is inserted, it'll likely be interlaced with\n  // nodes who may have injectors (e.g. node injector -> embedded view injector -> node injector).\n  // Since the bloom filters for the node injectors have already been constructed and we don't\n  // have a way of extracting the records from an injector, the only way to maintain the correct\n  // hierarchy when resolving the value is to walk it node-by-node while attempting to resolve\n  // the token at each level.\n  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */ && !(currentLView[FLAGS] & 512 /* LViewFlags.IsRoot */)) {\n    ngDevMode && assertTNodeForLView(currentTNode, currentLView);\n    // Note that this lookup on the node injector is using the `Self` flag, because\n    // we don't want the node injector to look at any parent injectors since we\n    // may hit the embedded view injector first.\n    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);\n    if (nodeInjectorValue !== NOT_FOUND) {\n      return nodeInjectorValue;\n    }\n    // Has an explicit type due to a TS bug: https://github.com/microsoft/TypeScript/issues/33191\n    let parentTNode = currentTNode.parent;\n    // `TNode.parent` includes the parent within the current view only. If it doesn't exist,\n    // it means that we've hit the view boundary and we need to go up to the next view.\n    if (!parentTNode) {\n      // Before we go to the next LView, check if the token exists on the current embedded injector.\n      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];\n      if (embeddedViewInjector) {\n        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);\n        if (embeddedViewInjectorValue !== NOT_FOUND) {\n          return embeddedViewInjectorValue;\n        }\n      }\n      // Otherwise keep going up the tree.\n      parentTNode = getTNodeFromLView(currentLView);\n      currentLView = currentLView[DECLARATION_VIEW];\n    }\n    currentTNode = parentTNode;\n  }\n  return notFoundValue;\n}\n/** Gets the TNode associated with an LView inside of the declaration view. */\nfunction getTNodeFromLView(lView) {\n  const tView = lView[TVIEW];\n  const tViewType = tView.type;\n  // The parent pointer differs based on `TView.type`.\n  if (tViewType === 2 /* TViewType.Embedded */) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  } else if (tViewType === 1 /* TViewType.Component */) {\n    // Components don't have `TView.declTNode` because each instance of component could be\n    // inserted in different location, hence `TView.declTNode` is meaningless.\n    return lView[T_HOST];\n  }\n  return null;\n}\n\n/**\n * Facade for the attribute injection from DI.\n *\n * @codeGenApi\n */\nfunction ɵɵinjectAttribute(attrNameToInject) {\n  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);\n}\nconst ANNOTATIONS = '__annotations__';\nconst PARAMETERS = '__parameters__';\nconst PROP_METADATA = '__prop__metadata__';\n/**\n * @suppress {globalThis}\n */\nfunction makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n    function DecoratorFactory(...args) {\n      if (this instanceof DecoratorFactory) {\n        metaCtor.call(this, ...args);\n        return this;\n      }\n      const annotationInstance = new DecoratorFactory(...args);\n      return function TypeDecorator(cls) {\n        if (typeFn) typeFn(cls, ...args);\n        // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {\n          value: []\n        })[ANNOTATIONS];\n        annotations.push(annotationInstance);\n        if (additionalProcessing) additionalProcessing(cls);\n        return cls;\n      };\n    }\n    if (parentClass) {\n      DecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    DecoratorFactory.prototype.ngMetadataName = name;\n    DecoratorFactory.annotationCls = DecoratorFactory;\n    return DecoratorFactory;\n  });\n}\nfunction makeMetadataCtor(props) {\n  return function ctor(...args) {\n    if (props) {\n      const values = props(...args);\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\nfunction makeParamDecorator(name, props, parentClass) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n    function ParamDecoratorFactory(...args) {\n      if (this instanceof ParamDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n      const annotationInstance = new ParamDecoratorFactory(...args);\n      ParamDecorator.annotation = annotationInstance;\n      return ParamDecorator;\n      function ParamDecorator(cls, unusedKey, index) {\n        // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {\n          value: []\n        })[PARAMETERS];\n        // there might be gaps if some in between parameters do not have annotations.\n        // we pad with nulls.\n        while (parameters.length <= index) {\n          parameters.push(null);\n        }\n        (parameters[index] = parameters[index] || []).push(annotationInstance);\n        return cls;\n      }\n    }\n    if (parentClass) {\n      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    ParamDecoratorFactory.prototype.ngMetadataName = name;\n    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n    return ParamDecoratorFactory;\n  });\n}\nfunction makePropDecorator(name, props, parentClass, additionalProcessing) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n    function PropDecoratorFactory(...args) {\n      if (this instanceof PropDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n      const decoratorInstance = new PropDecoratorFactory(...args);\n      function PropDecorator(target, name) {\n        // target is undefined with standard decorators. This case is not supported and will throw\n        // if this decorator is used in JIT mode with standard decorators.\n        if (target === undefined) {\n          throw new Error('Standard Angular field decorators are not supported in JIT mode.');\n        }\n        const constructor = target.constructor;\n        // Use of Object.defineProperty is important because it creates a non-enumerable property\n        // which prevents the property from being copied during subclassing.\n        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {\n          value: {}\n        })[PROP_METADATA];\n        meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n        meta[name].unshift(decoratorInstance);\n        if (additionalProcessing) additionalProcessing(target, name, ...args);\n      }\n      return PropDecorator;\n    }\n    if (parentClass) {\n      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    PropDecoratorFactory.prototype.ngMetadataName = name;\n    PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n    return PropDecoratorFactory;\n  });\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Attribute = makeParamDecorator('Attribute', attributeName => ({\n  attributeName,\n  __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName)\n}));\n\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nconst emitDistinctChangesOnlyDefaultValue = true;\n/**\n * Base class for query metadata.\n *\n * @see {@link ContentChildren}.\n * @see {@link ContentChild}.\n * @see {@link ViewChildren}.\n * @see {@link ViewChild}.\n *\n * @publicApi\n */\nclass Query {}\n/**\n * ContentChildren decorator and metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nconst ContentChildren = makePropDecorator('ContentChildren', (selector, data = {}) => ({\n  selector,\n  first: false,\n  isViewQuery: false,\n  descendants: false,\n  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,\n  ...data\n}), Query);\n/**\n * ContentChild decorator and metadata.\n *\n *\n * @Annotation\n *\n * @publicApi\n */\nconst ContentChild = makePropDecorator('ContentChild', (selector, data = {}) => ({\n  selector,\n  first: true,\n  isViewQuery: false,\n  descendants: true,\n  ...data\n}), Query);\n/**\n * ViewChildren decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst ViewChildren = makePropDecorator('ViewChildren', (selector, data = {}) => ({\n  selector,\n  first: false,\n  isViewQuery: true,\n  descendants: true,\n  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,\n  ...data\n}), Query);\n/**\n * ViewChild decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst ViewChild = makePropDecorator('ViewChild', (selector, data) => ({\n  selector,\n  first: true,\n  isViewQuery: true,\n  descendants: true,\n  ...data\n}), Query);\nvar FactoryTarget;\n(function (FactoryTarget) {\n  FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n  FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n  FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n  FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n  FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\nvar R3TemplateDependencyKind;\n(function (R3TemplateDependencyKind) {\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\nfunction getCompilerFacade(request) {\n  const globalNg = _global['ng'];\n  if (globalNg && globalNg.ɵcompilerFacade) {\n    return globalNg.ɵcompilerFacade;\n  }\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    // Log the type as an error so that a developer can easily navigate to the type from the\n    // console.\n    console.error(`JIT compilation failed for ${request.kind}`, request.type);\n    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\\n\\n`;\n    if (request.usage === 1 /* JitCompilerUsage.PartialDeclaration */) {\n      message += `The ${request.kind} is part of a library that has been partially compiled.\\n`;\n      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\\n`;\n      message += '\\n';\n      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\\n`;\n    } else {\n      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\\n`;\n    }\n    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\\n`;\n    message += `or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`;\n    throw new Error(message);\n  } else {\n    throw new Error('JIT compiler unavailable');\n  }\n}\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nconst Type = Function;\nfunction isType(v) {\n  return typeof v === 'function';\n}\n\n/**\n * Determines if the contents of two arrays is identical\n *\n * @param a first array\n * @param b second array\n * @param identityAccessor Optional function for extracting stable object identity from a value in\n *     the array.\n */\nfunction arrayEquals(a, b, identityAccessor) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    let valueA = a[i];\n    let valueB = b[i];\n    if (identityAccessor) {\n      valueA = identityAccessor(valueA);\n      valueB = identityAccessor(valueB);\n    }\n    if (valueB !== valueA) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Flattens an array.\n */\nfunction flatten(list) {\n  return list.flat(Number.POSITIVE_INFINITY);\n}\nfunction deepForEach(input, fn) {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\nfunction addToArray(arr, index, value) {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\nfunction removeFromArray(arr, index) {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\nfunction newArray(size, value) {\n  const list = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value);\n  }\n  return list;\n}\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nfunction arraySplice(array, index, count) {\n  const length = array.length - count;\n  while (index < length) {\n    array[index] = array[index + count];\n    index++;\n  }\n  while (count--) {\n    array.pop(); // shrink the array\n  }\n}\n/**\n * Same as `Array.splice(index, 0, value)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value Value to add to array.\n */\nfunction arrayInsert(array, index, value) {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n  while (end > index) {\n    const previousEnd = end - 1;\n    array[end] = array[previousEnd];\n    end = previousEnd;\n  }\n  array[index] = value;\n}\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nfunction arrayInsert2(array, index, value1, value2) {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n  if (end == index) {\n    // inserting at the end.\n    array.push(value1, value2);\n  } else if (end === 1) {\n    // corner case when we have less items in array than we have items to insert.\n    array.push(value2, array[0]);\n    array[0] = value1;\n  } else {\n    end--;\n    array.push(array[end - 1], array[end]);\n    while (end > index) {\n      const previousEnd = end - 2;\n      array[end] = array[previousEnd];\n      end--;\n    }\n    array[index] = value1;\n    array[index + 1] = value2;\n  }\n}\n/**\n * Get an index of an `value` in a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     located)\n */\nfunction arrayIndexOfSorted(array, value) {\n  return _arrayIndexOfSorted(array, value, 0);\n}\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nfunction keyValueArraySet(keyValueArray, key, value) {\n  let index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it set it.\n    keyValueArray[index | 1] = value;\n  } else {\n    index = ~index;\n    arrayInsert2(keyValueArray, index, key, value);\n  }\n  return index;\n}\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nfunction keyValueArrayGet(keyValueArray, key) {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it retrieve it.\n    return keyValueArray[index | 1];\n  }\n  return undefined;\n}\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n  return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\n/**\n * Delete a `key` (and `value`) from the `KeyValueArray`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or delete (if exist).\n * @returns index of where the key was (or should have been.)\n *   - positive (even) index if key found and deleted.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been.)\n */\nfunction keyValueArrayDelete(keyValueArray, key) {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it remove it.\n    arraySplice(keyValueArray, index, 2);\n  }\n  return index;\n}\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array, value, shift) {\n  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n  let start = 0;\n  let end = array.length >> shift;\n  while (end !== start) {\n    const middle = start + (end - start >> 1); // find the middle.\n    const current = array[middle << shift];\n    if (value === current) {\n      return middle << shift;\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\n    }\n  }\n\n  return ~(end << shift);\n}\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nconst ES5_DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nconst ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nconst ES2015_INHERITED_CLASS_WITH_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nconst ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nfunction isDelegateCtor(typeStr) {\n  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);\n}\nclass ReflectionCapabilities {\n  constructor(reflect) {\n    this._reflect = reflect || _global['Reflect'];\n  }\n  factory(t) {\n    return (...args) => new t(...args);\n  }\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {\n    let result;\n    if (typeof paramTypes === 'undefined') {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n  _ownParameters(type, parentCtor) {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    }\n    // Prefer the direct API.\n    if (type.parameters && type.parameters !== parentCtor.parameters) {\n      return type.parameters;\n    }\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = type.ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map(ctorParam => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(ctorParam => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return newArray(type.length);\n  }\n  parameters(type) {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n  _ownAnnotations(typeOrFunc, parentCtor) {\n    // Prefer the direct API.\n    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\n      let annotations = typeOrFunc.annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n    // API of tsickle for lowering decorators to properties on the class.\n    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n    }\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return typeOrFunc[ANNOTATIONS];\n    }\n    return null;\n  }\n  annotations(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n  _ownPropMetadata(typeOrFunc, parentCtor) {\n    // Prefer the direct API.\n    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = typeOrFunc.propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n    // API of tsickle for lowering decorators to properties on the class.\n    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = typeOrFunc.propDecorators;\n      const propMetadata = {};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return typeOrFunc[PROP_METADATA];\n    }\n    return null;\n  }\n  propMetadata(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach(propName => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach(propName => {\n        const decorators = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n  ownPropMetadata(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n  hasLifecycleHook(type, lcProperty) {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n}\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\nfunction getParentCtor(ctor) {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Inject = attachInjectFlag(\n// Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nmakeParamDecorator('Inject', token => ({\n  token\n})), -1 /* DecoratorFlags.Inject */);\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Optional =\n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Optional'), 8 /* InternalInjectFlags.Optional */);\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Self =\n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Self'), 2 /* InternalInjectFlags.Self */);\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst SkipSelf =\n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('SkipSelf'), 4 /* InternalInjectFlags.SkipSelf */);\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Host =\n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Host'), 1 /* InternalInjectFlags.Host */);\n\nlet _reflect = null;\nfunction getReflect() {\n  return _reflect = _reflect || new ReflectionCapabilities();\n}\nfunction reflectDependencies(type) {\n  return convertDependencies(getReflect().parameters(type));\n}\nfunction convertDependencies(deps) {\n  return deps.map(dep => reflectDependency(dep));\n}\nfunction reflectDependency(dep) {\n  const meta = {\n    token: null,\n    attribute: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false\n  };\n  if (Array.isArray(dep) && dep.length > 0) {\n    for (let j = 0; j < dep.length; j++) {\n      const param = dep[j];\n      if (param === undefined) {\n        // param may be undefined if type of dep is not set by ngtsc\n        continue;\n      }\n      const proto = Object.getPrototypeOf(param);\n      if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n        meta.optional = true;\n      } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n        meta.skipSelf = true;\n      } else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n        meta.self = true;\n      } else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n        meta.host = true;\n      } else if (param instanceof Inject) {\n        meta.token = param.token;\n      } else if (param instanceof Attribute) {\n        if (param.attributeName === undefined) {\n          throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Attribute name must be defined.`);\n        }\n        meta.attribute = param.attributeName;\n      } else {\n        meta.token = param;\n      }\n    }\n  } else if (dep === undefined || Array.isArray(dep) && dep.length === 0) {\n    meta.token = null;\n  } else {\n    meta.token = dep;\n  }\n  return meta;\n}\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nfunction resolveComponentResources(resourceResolver) {\n  // Store all promises which are fetching the resources.\n  const componentResolved = [];\n  // Cache so that we don't fetch the same resource more than once.\n  const urlMap = new Map();\n  function cachedResourceResolve(url) {\n    let promise = urlMap.get(url);\n    if (!promise) {\n      const resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n    return promise;\n  }\n  componentResourceResolutionQueue.forEach((component, type) => {\n    const promises = [];\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then(template => {\n        component.template = template;\n      }));\n    }\n    const styleUrls = component.styleUrls;\n    const styles = component.styles || (component.styles = []);\n    const styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach((styleUrl, index) => {\n      styles.push(''); // pre-allocate array.\n      promises.push(cachedResourceResolve(styleUrl).then(style => {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      }));\n    });\n    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(() => undefined);\n}\nlet componentResourceResolutionQueue = new Map();\n// Track when existing ɵcmp for a Type is waiting on resources.\nconst componentDefPendingResolution = new Set();\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\nfunction isComponentDefPendingResolution(type) {\n  return componentDefPendingResolution.has(type);\n}\nfunction componentNeedsResolution(component) {\n  return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls && component.styleUrls.length);\n}\nfunction clearResolutionOfComponentResourcesQueue() {\n  const old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = new Map();\n  return old;\n}\nfunction restoreComponentResolutionQueue(queue) {\n  componentDefPendingResolution.clear();\n  queue.forEach((_, type) => componentDefPendingResolution.add(type));\n  componentResourceResolutionQueue = queue;\n}\nfunction isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\nfunction unwrapResponse(response) {\n  return typeof response == 'string' ? response : response.text();\n}\nfunction componentDefResolved(type) {\n  componentDefPendingResolution.delete(type);\n}\n\n/**\n * Map of module-id to the corresponding NgModule.\n */\nconst modules = new Map();\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\nlet checkForDuplicateNgModules = true;\nfunction assertSameOrNotExisting(id, type, incoming) {\n  if (type && type !== incoming && checkForDuplicateNgModules) {\n    throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n  }\n}\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nfunction registerNgModuleType(ngModuleType, id) {\n  const existing = modules.get(id) || null;\n  assertSameOrNotExisting(id, existing, ngModuleType);\n  modules.set(id, ngModuleType);\n}\nfunction clearModulesForTest() {\n  modules.clear();\n}\nfunction getRegisteredNgModuleType(id) {\n  return modules.get(id);\n}\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nfunction setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {\n  checkForDuplicateNgModules = !allowDuplicates;\n}\n\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nconst CUSTOM_ELEMENTS_SCHEMA = {\n  name: 'custom-elements'\n};\n/**\n * Defines a schema that allows any property on any element.\n *\n * This schema allows you to ignore the errors related to any unknown elements or properties in a\n * template. The usage of this schema is generally discouraged because it prevents useful validation\n * and may hide real errors in your template. Consider using the `CUSTOM_ELEMENTS_SCHEMA` instead.\n *\n * @publicApi\n */\nconst NO_ERRORS_SCHEMA = {\n  name: 'no-errors-schema'\n};\nlet shouldThrowErrorOnUnknownElement = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown elements,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction ɵsetUnknownElementStrictMode(shouldThrow) {\n  shouldThrowErrorOnUnknownElement = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction ɵgetUnknownElementStrictMode() {\n  return shouldThrowErrorOnUnknownElement;\n}\nlet shouldThrowErrorOnUnknownProperty = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown properties,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction ɵsetUnknownPropertyStrictMode(shouldThrow) {\n  shouldThrowErrorOnUnknownProperty = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction ɵgetUnknownPropertyStrictMode() {\n  return shouldThrowErrorOnUnknownProperty;\n}\n/**\n * Validates that the element is known at runtime and produces\n * an error if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The element is considered known if either:\n * - it's a known HTML element\n * - it's a known custom element\n * - the element matches any directive\n * - the element is allowed by one of the schemas\n *\n * @param element Element to validate\n * @param lView An `LView` that represents a current component that is being rendered\n * @param tagName Name of the tag to check\n * @param schemas Array of schemas\n * @param hasDirectives Boolean indicating that the element matches any directive\n */\nfunction validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return;\n  // If the element matches any directive, it's considered as valid.\n  if (!hasDirectives && tagName !== null) {\n    // The element is unknown if it's an instance of HTMLUnknownElement, or it isn't registered\n    // as a custom element. Note that unknown elements with a dash in their name won't be instances\n    // of HTMLUnknownElement in browsers that support web components.\n    const isUnknown =\n    // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because\n    // Domino doesn't expose HTMLUnknownElement globally.\n    typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 && !customElements.get(tagName);\n    if (isUnknown && !matchingSchemas(schemas, tagName)) {\n      const isHostStandalone = isHostComponentStandalone(lView);\n      const templateLocation = getTemplateLocationDetails(lView);\n      const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n      let message = `'${tagName}' is not a known element${templateLocation}:\\n`;\n      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' : 'a part of an @NgModule where this component is declared'}.\\n`;\n      if (tagName && tagName.indexOf('-') > -1) {\n        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;\n      } else {\n        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n      }\n      if (shouldThrowErrorOnUnknownElement) {\n        throw new RuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message);\n      } else {\n        console.error(formatRuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message));\n      }\n    }\n  }\n}\n/**\n * Validates that the property of the element is known at runtime and returns\n * false if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The property is considered known if either:\n * - it's a known property of the element\n * - the element is allowed by one of the schemas\n * - the property is used for animations\n *\n * @param element Element to validate\n * @param propName Name of the property to check\n * @param tagName Name of the tag hosting the property\n * @param schemas Array of schemas\n */\nfunction isPropertyValid(element, propName, tagName, schemas) {\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return true;\n  // The property is considered valid if the element matches the schema, it exists on the element,\n  // or it is synthetic.\n  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {\n    return true;\n  }\n  // Note: `typeof Node` returns 'function' in most browsers, but is undefined with domino.\n  return typeof Node === 'undefined' || Node === null || !(element instanceof Node);\n}\n/**\n * Logs or throws an error that a property is not supported on an element.\n *\n * @param propName Name of the invalid property\n * @param tagName Name of the tag hosting the property\n * @param nodeType Type of the node hosting the property\n * @param lView An `LView` that represents a current component\n */\nfunction handleUnknownPropertyError(propName, tagName, nodeType, lView) {\n  // Special-case a situation when a structural directive is applied to\n  // an `<ng-template>` element, for example: `<ng-template *ngIf=\"true\">`.\n  // In this case the compiler generates the `ɵɵtemplate` instruction with\n  // the `null` as the tagName. The directive matching logic at runtime relies\n  // on this effect (see `isInlineTemplate`), thus using the 'ng-template' as\n  // a default value of the `tNode.value` is not feasible at this moment.\n  if (!tagName && nodeType === 4 /* TNodeType.Container */) {\n    tagName = 'ng-template';\n  }\n  const isHostStandalone = isHostComponentStandalone(lView);\n  const templateLocation = getTemplateLocationDetails(lView);\n  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;\n  const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n  const importLocation = isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' : 'a part of an @NgModule where this component is declared';\n  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {\n    // Most likely this is a control flow directive (such as `*ngIf`) used in\n    // a template, but the directive or the `CommonModule` is not imported.\n    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);\n    message += `\\nIf the '${propName}' is an Angular control flow directive, ` + `please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;\n  } else {\n    // May be an Angular component, which is not imported/declared?\n    message += `\\n1. If '${tagName}' is an Angular component and it has the ` + `'${propName}' input, then verify that it is ${importLocation}.`;\n    // May be a Web Component?\n    if (tagName && tagName.indexOf('-') > -1) {\n      message += `\\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` + `to the ${schemas} of this component to suppress this message.`;\n      message += `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;\n    } else {\n      // If it's expected, the error can be suppressed by the `NO_ERRORS_SCHEMA` schema.\n      message += `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;\n    }\n  }\n  reportUnknownPropertyError(message);\n}\nfunction reportUnknownPropertyError(message) {\n  if (shouldThrowErrorOnUnknownProperty) {\n    throw new RuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message);\n  } else {\n    console.error(formatRuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message));\n  }\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode and also it relies on the constructor function being available.\n *\n * Gets a reference to the host component def (where a current component is declared).\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getDeclarationComponentDef(lView) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n  const context = declarationLView[CONTEXT];\n  // Unable to obtain a context.\n  if (!context) return null;\n  return context.constructor ? getComponentDef(context.constructor) : null;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Checks if the current component is declared inside of a standalone component template.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction isHostComponentStandalone(lView) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  const componentDef = getDeclarationComponentDef(lView);\n  // Treat host component as non-standalone if we can't obtain the def.\n  return !!componentDef?.standalone;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Constructs a string describing the location of the host component template. The function is used\n * in dev mode to produce error messages.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getTemplateLocationDetails(lView) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  const hostComponentDef = getDeclarationComponentDef(lView);\n  const componentClassName = hostComponentDef?.type?.name;\n  return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';\n}\n/**\n * The set of known control flow directives and their corresponding imports.\n * We use this set to produce a more precises error message with a note\n * that the `CommonModule` should also be included.\n */\nconst KNOWN_CONTROL_FLOW_DIRECTIVES = new Map([['ngIf', 'NgIf'], ['ngFor', 'NgFor'], ['ngSwitchCase', 'NgSwitchCase'], ['ngSwitchDefault', 'NgSwitchDefault']]);\n/**\n * Returns true if the tag name is allowed by specified schemas.\n * @param schemas Array of schemas\n * @param tagName Name of the tag\n */\nfunction matchingSchemas(schemas, tagName) {\n  if (schemas !== null) {\n    for (let i = 0; i < schemas.length; i++) {\n      const schema = schemas[i];\n      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * The name of an attribute that can be added to the hydration boundary node\n * (component host node) to disable hydration for the content within that boundary.\n */\nconst SKIP_HYDRATION_ATTR_NAME = 'ngSkipHydration';\n/**\n * Helper function to check if a given TNode has the 'ngSkipHydration' attribute.\n */\nfunction hasSkipHydrationAttrOnTNode(tNode) {\n  const SKIP_HYDRATION_ATTR_NAME_LOWER_CASE = SKIP_HYDRATION_ATTR_NAME.toLowerCase();\n  const attrs = tNode.mergedAttrs;\n  if (attrs === null) return false;\n  // only ever look at the attribute name and skip the values\n  for (let i = 0; i < attrs.length; i += 2) {\n    const value = attrs[i];\n    // This is a marker, which means that the static attributes section is over,\n    // so we can exit early.\n    if (typeof value === 'number') return false;\n    if (typeof value === 'string' && value.toLowerCase() === SKIP_HYDRATION_ATTR_NAME_LOWER_CASE) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Helper function to check if a given RElement has the 'ngSkipHydration' attribute.\n */\nfunction hasSkipHydrationAttrOnRElement(rNode) {\n  return rNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME);\n}\n/**\n * Checks whether a TNode has a flag to indicate that it's a part of\n * a skip hydration block.\n */\nfunction hasInSkipHydrationBlockFlag(tNode) {\n  return (tNode.flags & 128 /* TNodeFlags.inSkipHydrationBlock */) === 128 /* TNodeFlags.inSkipHydrationBlock */;\n}\n/**\n * Helper function that determines if a given node is within a skip hydration block\n * by navigating up the TNode tree to see if any parent nodes have skip hydration\n * attribute.\n *\n * TODO(akushnir): this function should contain the logic of `hasInSkipHydrationBlockFlag`,\n * there is no need to traverse parent nodes when we have a TNode flag (which would also\n * make this lookup O(1)).\n */\nfunction isInSkipHydrationBlock(tNode) {\n  let currentTNode = tNode.parent;\n  while (currentTNode) {\n    if (hasSkipHydrationAttrOnTNode(currentTNode)) {\n      return true;\n    }\n    currentTNode = currentTNode.parent;\n  }\n  return false;\n}\n\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nvar RendererStyleFlags2;\n(function (RendererStyleFlags2) {\n  // TODO(misko): This needs to be refactored into a separate file so that it can be imported from\n  // `node_manipulation.ts` Currently doing the import cause resolution order to change and fails\n  // the tests. The work around is to have hard coded value in `node_manipulation.ts` for now.\n  /**\n   * Marks a style as important.\n   */\n  RendererStyleFlags2[RendererStyleFlags2[\"Important\"] = 1] = \"Important\";\n  /**\n   * Marks a style as using dash case naming (this-is-dash-case).\n   */\n  RendererStyleFlags2[RendererStyleFlags2[\"DashCase\"] = 2] = \"DashCase\";\n})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));\n\n/**\n * Disallowed strings in the comment.\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n */\nconst COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;\n/**\n * Delimiter in the disallowed strings which needs to be wrapped with zero with character.\n */\nconst COMMENT_DELIMITER = /(<|>)/;\nconst COMMENT_DELIMITER_ESCAPED = '\\u200B$1\\u200B';\n/**\n * Escape the content of comment strings so that it can be safely inserted into a comment node.\n *\n * The issue is that HTML does not specify any way to escape comment end text inside the comment.\n * Consider: `<!-- The way you close a comment is with \">\", and \"->\" at the beginning or by \"-->\" or\n * \"--!>\" at the end. -->`. Above the `\"-->\"` is meant to be text not an end to the comment. This\n * can be created programmatically through DOM APIs. (`<!--` are also disallowed.)\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n *\n * ```\n * div.innerHTML = div.innerHTML\n * ```\n *\n * One would expect that the above code would be safe to do, but it turns out that because comment\n * text is not escaped, the comment may contain text which will prematurely close the comment\n * opening up the application for XSS attack. (In SSR we programmatically create comment nodes which\n * may contain such text and expect them to be safe.)\n *\n * This function escapes the comment text by looking for comment delimiters (`<` and `>`) and\n * surrounding them with `_>_` where the `_` is a zero width space `\\u200B`. The result is that if a\n * comment contains any of the comment start/end delimiters (such as `<!--`, `-->` or `--!>`) the\n * text it will render normally but it will not cause the HTML parser to close/open the comment.\n *\n * @param value text to make safe for comment node by escaping the comment open/close character\n *     sequence.\n */\nfunction escapeCommentText(value) {\n  return value.replace(COMMENT_DISALLOWED, text => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));\n}\n\n// Keeps track of the currently-active LViews.\nconst TRACKED_LVIEWS = new Map();\n// Used for generating unique IDs for LViews.\nlet uniqueIdCounter = 0;\n/** Gets a unique ID that can be assigned to an LView. */\nfunction getUniqueLViewId() {\n  return uniqueIdCounter++;\n}\n/** Starts tracking an LView. */\nfunction registerLView(lView) {\n  ngDevMode && assertNumber(lView[ID], 'LView must have an ID in order to be registered');\n  TRACKED_LVIEWS.set(lView[ID], lView);\n}\n/** Gets an LView by its unique ID. */\nfunction getLViewById(id) {\n  ngDevMode && assertNumber(id, 'ID used for LView lookup must be a number');\n  return TRACKED_LVIEWS.get(id) || null;\n}\n/** Stops tracking an LView. */\nfunction unregisterLView(lView) {\n  ngDevMode && assertNumber(lView[ID], 'Cannot stop tracking an LView that does not have an ID');\n  TRACKED_LVIEWS.delete(lView[ID]);\n}\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nclass LContext {\n  /** Component's parent view data. */\n  get lView() {\n    return getLViewById(this.lViewId);\n  }\n  constructor(\n  /**\n   * ID of the component's parent view data.\n   */\n  lViewId,\n  /**\n   * The index instance of the node.\n   */\n  nodeIndex,\n  /**\n   * The instance of the DOM node that is attached to the lNode.\n   */\n  native) {\n    this.lViewId = lViewId;\n    this.nodeIndex = nodeIndex;\n    this.native = native;\n  }\n}\n\n/**\n * Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nfunction getLContext(target) {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    // only when it's an array is it considered an LView instance\n    // ... otherwise it's an already constructed LContext instance\n    if (isLView(mpValue)) {\n      const lView = mpValue;\n      let nodeIndex;\n      let component = undefined;\n      let directives = undefined;\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n      // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, component, container, ICU\n      // expression or directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n      const native = unwrapRNode(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);\n      // only when the component has been discovered then update the monkey-patch\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      }\n      // only when the directives have been discovered then update the monkey-patch\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target;\n    ngDevMode && assertDomNode(rElement);\n    // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n    let parent = rElement;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;\n        // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n        if (!lView) {\n          return null;\n        }\n        const index = findViaNativeElement(lView, rElement);\n        if (index >= 0) {\n          const native = unwrapRNode(lView[index]);\n          const context = createLContext(lView, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n  return mpValue || null;\n}\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView, nodeIndex, native) {\n  return new LContext(lView[ID], nodeIndex, native);\n}\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nfunction getComponentViewByInstance(componentInstance) {\n  let patchedData = readPatchedData(componentInstance);\n  let lView;\n  if (isLView(patchedData)) {\n    const contextLView = patchedData;\n    const nodeIndex = findViaComponent(contextLView, componentInstance);\n    lView = getComponentLViewByIndex(nodeIndex, contextLView);\n    const context = createLContext(contextLView, nodeIndex, lView[HOST]);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = patchedData;\n    const contextLView = context.lView;\n    ngDevMode && assertLView(contextLView);\n    lView = getComponentLViewByIndex(context.nodeIndex, contextLView);\n  }\n  return lView;\n}\n/**\n * This property will be monkey-patched on elements, components and directives.\n */\nconst MONKEY_PATCH_KEY_NAME = '__ngContext__';\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nfunction attachPatchData(target, data) {\n  ngDevMode && assertDefined(target, 'Target expected');\n  // Only attach the ID of the view in order to avoid memory leaks (see #41047). We only do this\n  // for `LView`, because we have control over when an `LView` is created and destroyed, whereas\n  // we can't know when to remove an `LContext`.\n  if (isLView(data)) {\n    target[MONKEY_PATCH_KEY_NAME] = data[ID];\n    registerLView(data);\n  } else {\n    target[MONKEY_PATCH_KEY_NAME] = data;\n  }\n}\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nfunction readPatchedData(target) {\n  ngDevMode && assertDefined(target, 'Target expected');\n  const data = target[MONKEY_PATCH_KEY_NAME];\n  return typeof data === 'number' ? getLViewById(data) : data || null;\n}\nfunction readPatchedLView(target) {\n  const value = readPatchedData(target);\n  if (value) {\n    return isLView(value) ? value : value.lView;\n  }\n  return null;\n}\nfunction isComponentInstance(instance) {\n  return instance && instance.constructor && instance.constructor.ɵcmp;\n}\nfunction isDirectiveInstance(instance) {\n  return instance && instance.constructor && instance.constructor.ɵdir;\n}\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView, target) {\n  const tView = lView[TVIEW];\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    if (unwrapRNode(lView[i]) === target) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode) {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else {\n    // Let's take the following template: <div><span>text</span></div><component/>\n    // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n    // in this case the parent `div`, so that we can find the component.\n    while (tNode.parent && !tNode.parent.next) {\n      tNode = tNode.parent;\n    }\n    return tNode.parent && tNode.parent.next;\n  }\n}\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView, componentInstance) {\n  const componentIndices = lView[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView, directiveInstance) {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LView of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = tNode.directiveStart;\n    const directiveIndexEnd = tNode.directiveEnd;\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\n/**\n * Returns a list of directives applied to a node at a specific index. The list includes\n * directives matched by selector and any host directives, but it excludes components.\n * Use `getComponentAtNodeIndex` to find the component applied to a node.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n */\nfunction getDirectivesAtNodeIndex(nodeIndex, lView) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  if (tNode.directiveStart === 0) return EMPTY_ARRAY;\n  const results = [];\n  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n    const directiveInstance = lView[i];\n    if (!isComponentInstance(directiveInstance)) {\n      results.push(directiveInstance);\n    }\n  }\n  return results;\n}\nfunction getComponentAtNodeIndex(nodeIndex, lView) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  const {\n    directiveStart,\n    componentOffset\n  } = tNode;\n  return componentOffset > -1 ? lView[directiveStart + componentOffset] : null;\n}\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nfunction discoverLocalRefs(lView, nodeIndex) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  if (tNode && tNode.localNames) {\n    const result = {};\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      result[tNode.localNames[i]] = lView[localIndex];\n      localIndex++;\n    }\n    return result;\n  }\n  return null;\n}\nlet _icuContainerIterate;\n/**\n * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.\n */\nfunction icuContainerIterate(tIcuContainerNode, lView) {\n  return _icuContainerIterate(tIcuContainerNode, lView);\n}\n/**\n * Ensures that `IcuContainerVisitor`'s implementation is present.\n *\n * This function is invoked when i18n instruction comes across an ICU. The purpose is to allow the\n * bundler to tree shake ICU logic and only load it if ICU instruction is executed.\n */\nfunction ensureIcuContainerVisitorLoaded(loader) {\n  if (_icuContainerIterate === undefined) {\n    // Do not inline this function. We want to keep `ensureIcuContainerVisitorLoaded` light, so it\n    // can be inlined into call-site.\n    _icuContainerIterate = loader();\n  }\n}\n\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nfunction getLViewParent(lView) {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT] : parent;\n}\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nfunction getRootView(componentOrLView) {\n  ngDevMode && assertDefined(componentOrLView, 'component');\n  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);\n  while (lView && !(lView[FLAGS] & 512 /* LViewFlags.IsRoot */)) {\n    lView = getLViewParent(lView);\n  }\n  ngDevMode && assertLView(lView);\n  return lView;\n}\n/**\n * Returns the context information associated with the application where the target is situated. It\n * does this by walking the parent views until it gets to the root view, then getting the context\n * off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nfunction getRootContext(viewOrComponent) {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode && assertDefined(rootView[CONTEXT], 'Root view has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT];\n}\n/**\n * Gets the first `LContainer` in the LView or `null` if none exists.\n */\nfunction getFirstLContainer(lView) {\n  return getNearestLContainer(lView[CHILD_HEAD]);\n}\n/**\n * Gets the next `LContainer` that is a sibling of the given container.\n */\nfunction getNextLContainer(container) {\n  return getNearestLContainer(container[NEXT]);\n}\nfunction getNearestLContainer(viewOrContainer) {\n  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n    viewOrContainer = viewOrContainer[NEXT];\n  }\n  return viewOrContainer;\n}\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {\n  // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n  // won't be created until i18nApply() in the update block, so this node should be skipped.\n  // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n  // in `i18n_spec.ts`.\n  if (lNodeToHandle != null) {\n    let lContainer;\n    let isComponent = false;\n    // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n    // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n    // it has LContainer so that we can process all of those cases appropriately.\n    if (isLContainer(lNodeToHandle)) {\n      lContainer = lNodeToHandle;\n    } else if (isLView(lNodeToHandle)) {\n      isComponent = true;\n      ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n      lNodeToHandle = lNodeToHandle[HOST];\n    }\n    const rNode = unwrapRNode(lNodeToHandle);\n    if (action === 0 /* WalkTNodeTreeAction.Create */ && parent !== null) {\n      if (beforeNode == null) {\n        nativeAppendChild(renderer, parent, rNode);\n      } else {\n        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n      }\n    } else if (action === 1 /* WalkTNodeTreeAction.Insert */ && parent !== null) {\n      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n    } else if (action === 2 /* WalkTNodeTreeAction.Detach */) {\n      nativeRemoveNode(renderer, rNode, isComponent);\n    } else if (action === 3 /* WalkTNodeTreeAction.Destroy */) {\n      ngDevMode && ngDevMode.rendererDestroyNode++;\n      renderer.destroyNode(rNode);\n    }\n    if (lContainer != null) {\n      applyContainer(renderer, action, lContainer, parent, beforeNode);\n    }\n  }\n}\nfunction createTextNode(renderer, value) {\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  ngDevMode && ngDevMode.rendererSetText++;\n  return renderer.createText(value);\n}\nfunction updateTextNode(renderer, rNode, value) {\n  ngDevMode && ngDevMode.rendererSetText++;\n  renderer.setValue(rNode, value);\n}\nfunction createCommentNode(renderer, value) {\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  return renderer.createComment(escapeCommentText(value));\n}\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param renderer A renderer to use\n * @param name the tag name\n * @param namespace Optional namespace for element.\n * @returns the element created\n */\nfunction createElementNode(renderer, name, namespace) {\n  ngDevMode && ngDevMode.rendererCreateElement++;\n  return renderer.createElement(name, namespace);\n}\n/**\n * Removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n */\nfunction removeViewFromContainer(tView, lView) {\n  const renderer = lView[RENDERER];\n  applyView(tView, lView, renderer, 2 /* WalkTNodeTreeAction.Detach */, null, null);\n  lView[HOST] = null;\n  lView[T_HOST] = null;\n}\n/**\n * Adds all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to add all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param parentTNode The `TNode` where the `LView` should be attached to.\n * @param renderer Current renderer to use for DOM manipulations.\n * @param lView The view from which elements should be added or removed\n * @param parentNativeNode The parent `RElement` where it should be inserted into.\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nfunction addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {\n  lView[HOST] = parentNativeNode;\n  lView[T_HOST] = parentTNode;\n  applyView(tView, lView, renderer, 1 /* WalkTNodeTreeAction.Insert */, parentNativeNode, beforeNode);\n}\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\nfunction renderDetachView(tView, lView) {\n  applyView(tView, lView, lView[RENDERER], 2 /* WalkTNodeTreeAction.Detach */, null, null);\n}\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nfunction destroyViewTree(rootView) {\n  // If the view has no children, we can clean it up and return early.\n  let lViewOrLContainer = rootView[CHILD_HEAD];\n  if (!lViewOrLContainer) {\n    return cleanUpView(rootView[TVIEW], rootView);\n  }\n  while (lViewOrLContainer) {\n    let next = null;\n    if (isLView(lViewOrLContainer)) {\n      // If LView, traverse down to child.\n      next = lViewOrLContainer[CHILD_HEAD];\n    } else {\n      ngDevMode && assertLContainer(lViewOrLContainer);\n      // If container, traverse down to its first LView.\n      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n      if (firstView) next = firstView;\n    }\n    if (!next) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {\n        if (isLView(lViewOrLContainer)) {\n          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n        }\n        lViewOrLContainer = lViewOrLContainer[PARENT];\n      }\n      if (lViewOrLContainer === null) lViewOrLContainer = rootView;\n      if (isLView(lViewOrLContainer)) {\n        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n      }\n      next = lViewOrLContainer && lViewOrLContainer[NEXT];\n    }\n    lViewOrLContainer = next;\n  }\n}\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param tView The `TView' of the `LView` to insert\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\nfunction insertView(tView, lView, lContainer, index) {\n  ngDevMode && assertLView(lView);\n  ngDevMode && assertLContainer(lContainer);\n  const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n  const containerLength = lContainer.length;\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    lContainer[indexInContainer - 1][NEXT] = lView;\n  }\n  if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n    lView[NEXT] = lContainer[indexInContainer];\n    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n  } else {\n    lContainer.push(lView);\n    lView[NEXT] = null;\n  }\n  lView[PARENT] = lContainer;\n  // track views where declaration and insertion points are different\n  const declarationLContainer = lView[DECLARATION_LCONTAINER];\n  if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n    trackMovedView(declarationLContainer, lView);\n  }\n  // notify query that a new view has been added\n  const lQueries = lView[QUERIES];\n  if (lQueries !== null) {\n    lQueries.insertView(tView);\n  }\n  // Sets the attached flag\n  lView[FLAGS] |= 128 /* LViewFlags.Attached */;\n}\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\nfunction trackMovedView(declarationContainer, lView) {\n  ngDevMode && assertDefined(lView, 'LView required');\n  ngDevMode && assertLContainer(declarationContainer);\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const insertedLContainer = lView[PARENT];\n  ngDevMode && assertLContainer(insertedLContainer);\n  const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n  const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n  if (declaredComponentLView !== insertedComponentLView) {\n    // At this point the declaration-component is not same as insertion-component; this means that\n    // this is a transplanted view. Mark the declared lView as having transplanted views so that\n    // those views can participate in CD.\n    declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;\n  }\n  if (movedViews === null) {\n    declarationContainer[MOVED_VIEWS] = [lView];\n  } else {\n    movedViews.push(lView);\n  }\n}\nfunction detachMovedView(declarationContainer, lView) {\n  ngDevMode && assertLContainer(declarationContainer);\n  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const declarationViewIndex = movedViews.indexOf(lView);\n  const insertionLContainer = lView[PARENT];\n  ngDevMode && assertLContainer(insertionLContainer);\n  // If the view was marked for refresh but then detached before it was checked (where the flag\n  // would be cleared and the counter decremented), we need to update the status here.\n  clearViewRefreshFlag(lView);\n  movedViews.splice(declarationViewIndex, 1);\n}\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\nfunction detachView(lContainer, removeIndex) {\n  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;\n  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n  const viewToDetach = lContainer[indexInContainer];\n  if (viewToDetach) {\n    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n      detachMovedView(declarationLContainer, viewToDetach);\n    }\n    if (removeIndex > 0) {\n      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];\n    }\n    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n    removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);\n    // notify query that a view has been removed\n    const lQueries = removedLView[QUERIES];\n    if (lQueries !== null) {\n      lQueries.detachView(removedLView[TVIEW]);\n    }\n    viewToDetach[PARENT] = null;\n    viewToDetach[NEXT] = null;\n    // Unsets the attached flag\n    viewToDetach[FLAGS] &= ~128 /* LViewFlags.Attached */;\n  }\n\n  return viewToDetach;\n}\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\nfunction destroyLView(tView, lView) {\n  if (!(lView[FLAGS] & 256 /* LViewFlags.Destroyed */)) {\n    const renderer = lView[RENDERER];\n    lView[REACTIVE_TEMPLATE_CONSUMER]?.destroy();\n    lView[REACTIVE_HOST_BINDING_CONSUMER]?.destroy();\n    if (renderer.destroyNode) {\n      applyView(tView, lView, renderer, 3 /* WalkTNodeTreeAction.Destroy */, null, null);\n    }\n    destroyViewTree(lView);\n  }\n}\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\nfunction cleanUpView(tView, lView) {\n  if (!(lView[FLAGS] & 256 /* LViewFlags.Destroyed */)) {\n    // Usually the Attached flag is removed when the view is detached from its parent, however\n    // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n    lView[FLAGS] &= ~128 /* LViewFlags.Attached */;\n    // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n    // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n    // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n    // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n    // really more of an \"afterDestroy\" hook if you think about it.\n    lView[FLAGS] |= 256 /* LViewFlags.Destroyed */;\n    executeOnDestroys(tView, lView);\n    processCleanups(tView, lView);\n    // For component views only, the local renderer is destroyed at clean up time.\n    if (lView[TVIEW].type === 1 /* TViewType.Component */) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      lView[RENDERER].destroy();\n    }\n    const declarationContainer = lView[DECLARATION_LCONTAINER];\n    // we are dealing with an embedded view that is still inserted into a container\n    if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n      // and this is a projected view\n      if (declarationContainer !== lView[PARENT]) {\n        detachMovedView(declarationContainer, lView);\n      }\n      // For embedded views still attached to a container: remove query result from this view.\n      const lQueries = lView[QUERIES];\n      if (lQueries !== null) {\n        lQueries.detachView(tView);\n      }\n    }\n    // Unregister the view once everything else has been cleaned up.\n    unregisterLView(lView);\n  }\n}\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction processCleanups(tView, lView) {\n  const tCleanup = tView.cleanup;\n  const lCleanup = lView[CLEANUP];\n  if (tCleanup !== null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a native DOM listener. It will occupy 4 entries in the TCleanup array (hence i +=\n        // 2 at the end of this block).\n        const targetIdx = tCleanup[i + 3];\n        ngDevMode && assertNumber(targetIdx, 'cleanup target must be a number');\n        if (targetIdx >= 0) {\n          // unregister\n          lCleanup[targetIdx]();\n        } else {\n          // Subscription\n          lCleanup[-targetIdx].unsubscribe();\n        }\n        i += 2;\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n  }\n  if (lCleanup !== null) {\n    lView[CLEANUP] = null;\n  }\n  const destroyHooks = lView[ON_DESTROY_HOOKS];\n  if (destroyHooks !== null) {\n    // Reset the ON_DESTROY_HOOKS array before iterating over it to prevent hooks that unregister\n    // themselves from mutating the array during iteration.\n    lView[ON_DESTROY_HOOKS] = null;\n    for (let i = 0; i < destroyHooks.length; i++) {\n      const destroyHooksFn = destroyHooks[i];\n      ngDevMode && assertFunction(destroyHooksFn, 'Expecting destroy hook to be a function.');\n      destroyHooksFn();\n    }\n  }\n}\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(tView, lView) {\n  let destroyHooks;\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    for (let i = 0; i < destroyHooks.length; i += 2) {\n      const context = lView[destroyHooks[i]];\n      // Only call the destroy hook if the context has been requested.\n      if (!(context instanceof NodeInjectorFactory)) {\n        const toCall = destroyHooks[i + 1];\n        if (Array.isArray(toCall)) {\n          for (let j = 0; j < toCall.length; j += 2) {\n            const callContext = context[toCall[j]];\n            const hook = toCall[j + 1];\n            profiler(4 /* ProfilerEvent.LifecycleHookStart */, callContext, hook);\n            try {\n              hook.call(callContext);\n            } finally {\n              profiler(5 /* ProfilerEvent.LifecycleHookEnd */, callContext, hook);\n            }\n          }\n        } else {\n          profiler(4 /* ProfilerEvent.LifecycleHookStart */, context, toCall);\n          try {\n            toCall.call(context);\n          } finally {\n            profiler(5 /* ProfilerEvent.LifecycleHookEnd */, context, toCall);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve render parent.\n * @param lView: Current `LView`.\n */\nfunction getParentRElement(tView, tNode, lView) {\n  return getClosestRElement(tView, tNode.parent, lView);\n}\n/**\n * Get closest `RElement` or `null` if it can't be found.\n *\n * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n * If `TNode` is `null` then return host `RElement`:\n *   - return `null` if projection\n *   - return `null` if parent container is disconnected (we have no parent.)\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n *     needed).\n * @param lView: Current `LView`.\n * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n */\nfunction getClosestRElement(tView, tNode, lView) {\n  let parentTNode = tNode;\n  // Skip over element and ICU containers as those are represented by a comment node and\n  // can't be used as a render parent.\n  while (parentTNode !== null && parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */)) {\n    tNode = parentTNode;\n    parentTNode = tNode.parent;\n  }\n  // If the parent tNode is null, then we are inserting across views: either into an embedded view\n  // or a component view.\n  if (parentTNode === null) {\n    // We are inserting a root element of the component view into the component host element and\n    // it should always be eager.\n    return lView[HOST];\n  } else {\n    ngDevMode && assertTNodeType(parentTNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n    const {\n      componentOffset\n    } = parentTNode;\n    if (componentOffset > -1) {\n      ngDevMode && assertTNodeForLView(parentTNode, lView);\n      const {\n        encapsulation\n      } = tView.data[parentTNode.directiveStart + componentOffset];\n      // We've got a parent which is an element in the current view. We just need to verify if the\n      // parent element is not a component. Component's content nodes are not inserted immediately\n      // because they will be projected, and so doing insert at this point would be wasteful.\n      // Since the projection would then move it to its final destination. Note that we can't\n      // make this assumption when using the Shadow DOM, because the native projection placeholders\n      // (<content> or <slot>) have to be in place as elements are being inserted.\n      if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) {\n        return null;\n      }\n    }\n    return getNativeByTNode(parentTNode, lView);\n  }\n}\n/**\n * Inserts a native node before another native node for a given parent.\n * This is a utility function that can be used when native nodes were determined.\n */\nfunction nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {\n  ngDevMode && ngDevMode.rendererInsertBefore++;\n  renderer.insertBefore(parent, child, beforeNode, isMove);\n}\nfunction nativeAppendChild(renderer, parent, child) {\n  ngDevMode && ngDevMode.rendererAppendChild++;\n  ngDevMode && assertDefined(parent, 'parent node must be defined');\n  renderer.appendChild(parent, child);\n}\nfunction nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {\n  if (beforeNode !== null) {\n    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n  } else {\n    nativeAppendChild(renderer, parent, child);\n  }\n}\n/** Removes a node from the DOM given its native parent. */\nfunction nativeRemoveChild(renderer, parent, child, isHostElement) {\n  renderer.removeChild(parent, child, isHostElement);\n}\n/** Checks if an element is a `<template>` node. */\nfunction isTemplateNode(node) {\n  return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\n/**\n * Returns a native parent of a given native node.\n */\nfunction nativeParentNode(renderer, node) {\n  return renderer.parentNode(node);\n}\n/**\n * Returns a native sibling of a given native node.\n */\nfunction nativeNextSibling(renderer, node) {\n  return renderer.nextSibling(node);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted.\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account if i18n code has been invoked.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {\n  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted. (Does not take i18n into\n * account)\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * does not take `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {\n  if (parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */)) {\n    return getNativeByTNode(parentTNode, lView);\n  }\n  return null;\n}\n/**\n * Tree shakable boundary for `getInsertInFrontOfRNodeWithI18n` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;\n/**\n * Tree shakable boundary for `processI18nInsertBefore` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _processI18nInsertBefore;\nfunction setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore) {\n  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;\n  _processI18nInsertBefore = processI18nInsertBefore;\n}\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * @param tView The `TView' to be appended\n * @param lView The current LView\n * @param childRNode The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n */\nfunction appendChild(tView, lView, childRNode, childTNode) {\n  const parentRNode = getParentRElement(tView, childTNode, lView);\n  const renderer = lView[RENDERER];\n  const parentTNode = childTNode.parent || lView[T_HOST];\n  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n  if (parentRNode != null) {\n    if (Array.isArray(childRNode)) {\n      for (let i = 0; i < childRNode.length; i++) {\n        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n      }\n    } else {\n      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n    }\n  }\n  _processI18nInsertBefore !== undefined && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\nfunction getFirstNativeNode(lView, tNode) {\n  if (tNode !== null) {\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 32 /* TNodeType.Icu */ | 16 /* TNodeType.Projection */);\n    const tNodeType = tNode.type;\n    if (tNodeType & 3 /* TNodeType.AnyRNode */) {\n      return getNativeByTNode(tNode, lView);\n    } else if (tNodeType & 4 /* TNodeType.Container */) {\n      return getBeforeNodeForView(-1, lView[tNode.index]);\n    } else if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n      const elIcuContainerChild = tNode.child;\n      if (elIcuContainerChild !== null) {\n        return getFirstNativeNode(lView, elIcuContainerChild);\n      } else {\n        const rNodeOrLContainer = lView[tNode.index];\n        if (isLContainer(rNodeOrLContainer)) {\n          return getBeforeNodeForView(-1, rNodeOrLContainer);\n        } else {\n          return unwrapRNode(rNodeOrLContainer);\n        }\n      }\n    } else if (tNodeType & 32 /* TNodeType.Icu */) {\n      let nextRNode = icuContainerIterate(tNode, lView);\n      let rNode = nextRNode();\n      // If the ICU container has no nodes, than we use the ICU anchor as the node.\n      return rNode || unwrapRNode(lView[tNode.index]);\n    } else {\n      const projectionNodes = getProjectionNodes(lView, tNode);\n      if (projectionNodes !== null) {\n        if (Array.isArray(projectionNodes)) {\n          return projectionNodes[0];\n        }\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        return getFirstNativeNode(parentView, projectionNodes);\n      } else {\n        return getFirstNativeNode(lView, tNode.next);\n      }\n    }\n  }\n  return null;\n}\nfunction getProjectionNodes(lView, tNode) {\n  if (tNode !== null) {\n    const componentView = lView[DECLARATION_COMPONENT_VIEW];\n    const componentHost = componentView[T_HOST];\n    const slotIdx = tNode.projection;\n    ngDevMode && assertProjectionSlots(lView);\n    return componentHost.projection[slotIdx];\n  }\n  return null;\n}\nfunction getBeforeNodeForView(viewIndexInContainer, lContainer) {\n  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n  if (nextViewIndex < lContainer.length) {\n    const lView = lContainer[nextViewIndex];\n    const firstTNodeOfView = lView[TVIEW].firstChild;\n    if (firstTNodeOfView !== null) {\n      return getFirstNativeNode(lView, firstTNodeOfView);\n    }\n  }\n  return lContainer[NATIVE];\n}\n/**\n * Removes a native node itself using a given renderer. To remove the node we are looking up its\n * parent from the native tree as not all platforms / browsers support the equivalent of\n * node.remove().\n *\n * @param renderer A renderer to be used\n * @param rNode The native node that should be removed\n * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n */\nfunction nativeRemoveNode(renderer, rNode, isHostElement) {\n  ngDevMode && ngDevMode.rendererRemoveNode++;\n  const nativeParent = nativeParentNode(renderer, rNode);\n  if (nativeParent) {\n    nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n  }\n}\n/**\n * Clears the contents of a given RElement.\n *\n * @param rElement the native RElement to be cleared\n */\nfunction clearElementContents(rElement) {\n  rElement.textContent = '';\n}\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\nfunction applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {\n  while (tNode != null) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n    const rawSlotValue = lView[tNode.index];\n    const tNodeType = tNode.type;\n    if (isProjection) {\n      if (action === 0 /* WalkTNodeTreeAction.Create */) {\n        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n        tNode.flags |= 2 /* TNodeFlags.isProjected */;\n      }\n    }\n\n    if ((tNode.flags & 32 /* TNodeFlags.isDetached */) !== 32 /* TNodeFlags.isDetached */) {\n      if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & 32 /* TNodeType.Icu */) {\n        const nextRNode = icuContainerIterate(tNode, lView);\n        let rNode;\n        while (rNode = nextRNode()) {\n          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n        }\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & 16 /* TNodeType.Projection */) {\n        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);\n      } else {\n        ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n}\nfunction applyView(tView, lView, renderer, action, parentRElement, beforeNode) {\n  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param tView The `TView` of `LView` which needs to be inserted, detached, destroyed\n * @param lView The `LView` which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\nfunction applyProjection(tView, lView, tProjectionNode) {\n  const renderer = lView[RENDERER];\n  const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n  const parentTNode = tProjectionNode.parent || lView[T_HOST];\n  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n  applyProjectionRecursive(renderer, 0 /* WalkTNodeTreeAction.Create */, lView, tProjectionNode, parentRNode, beforeNode);\n}\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {\n  const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n  const componentNode = componentLView[T_HOST];\n  ngDevMode && assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];\n  if (Array.isArray(nodeToProjectOrRNodes)) {\n    // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n    // need to support passing projectable nodes, so we cheat and put them in the TNode\n    // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n    // because we know that that TView is not shared and therefore it will not be a problem.\n    // This should be refactored and cleaned up.\n    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n      const rNode = nodeToProjectOrRNodes[i];\n      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n    }\n  } else {\n    let nodeToProject = nodeToProjectOrRNodes;\n    const projectedComponentLView = componentLView[PARENT];\n    // If a parent <ng-content> is located within a skip hydration block,\n    // annotate an actual node that is being projected with the same flag too.\n    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {\n      nodeToProject.flags |= 128 /* TNodeFlags.inSkipHydrationBlock */;\n    }\n\n    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n  }\n}\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {\n  ngDevMode && assertLContainer(lContainer);\n  const anchor = lContainer[NATIVE]; // LContainer has its own before node.\n  const native = unwrapRNode(lContainer);\n  // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n  // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n  // node (comment in the DOM) that will be different from the LContainer's host node. In this\n  // particular case we need to execute action on 2 nodes:\n  // - container's host node (this is done in the executeActionOnElementOrContainer)\n  // - container's host node (this is done here)\n  if (anchor !== native) {\n    // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n    // don't see a reason why they should be different, but they are.\n    //\n    // If they are we need to process the second anchor as well.\n    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n  }\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lView = lContainer[i];\n    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n  }\n}\n/**\n * Writes class/style to element.\n *\n * @param renderer Renderer to use.\n * @param isClassBased `true` if it should be written to `class` (`false` to write to `style`)\n * @param rNode The Node to write to.\n * @param prop Property to write to. This would be the class/style name.\n * @param value Value to write. If `null`/`undefined`/`false` this is considered a remove (set/add\n *        otherwise).\n */\nfunction applyStyling(renderer, isClassBased, rNode, prop, value) {\n  if (isClassBased) {\n    // We actually want JS true/false here because any truthy value should add the class\n    if (!value) {\n      ngDevMode && ngDevMode.rendererRemoveClass++;\n      renderer.removeClass(rNode, prop);\n    } else {\n      ngDevMode && ngDevMode.rendererAddClass++;\n      renderer.addClass(rNode, prop);\n    }\n  } else {\n    let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase;\n    if (value == null /** || value === undefined */) {\n      ngDevMode && ngDevMode.rendererRemoveStyle++;\n      renderer.removeStyle(rNode, prop, flags);\n    } else {\n      // A value is important if it ends with `!important`. The style\n      // parser strips any semicolons at the end of the value.\n      const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;\n      if (isImportant) {\n        // !important has to be stripped from the value for it to be valid.\n        value = value.slice(0, -10);\n        flags |= RendererStyleFlags2.Important;\n      }\n      ngDevMode && ngDevMode.rendererSetStyle++;\n      renderer.setStyle(rNode, prop, value, flags);\n    }\n  }\n}\n/**\n * Write `cssText` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectStyle(renderer, element, newValue) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n  renderer.setAttribute(element, 'style', newValue);\n  ngDevMode && ngDevMode.rendererSetStyle++;\n}\n/**\n * Write `className` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectClass(renderer, element, newValue) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n  if (newValue === '') {\n    // There are tests in `google3` which expect `element.getAttribute('class')` to be `null`.\n    renderer.removeAttribute(element, 'class');\n  } else {\n    renderer.setAttribute(element, 'class', newValue);\n  }\n  ngDevMode && ngDevMode.rendererSetClassName++;\n}\n/** Sets up the static DOM attributes on an `RNode`. */\nfunction setupStaticAttributes(renderer, element, tNode) {\n  const {\n    mergedAttrs,\n    classes,\n    styles\n  } = tNode;\n  if (mergedAttrs !== null) {\n    setUpAttributes(renderer, element, mergedAttrs);\n  }\n  if (classes !== null) {\n    writeDirectClass(renderer, element, classes);\n  }\n  if (styles !== null) {\n    writeDirectStyle(renderer, element, styles);\n  }\n}\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy$1;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy$1() {\n  if (policy$1 === undefined) {\n    policy$1 = null;\n    if (_global.trustedTypes) {\n      try {\n        policy$1 = _global.trustedTypes.createPolicy('angular', {\n          createHTML: s => s,\n          createScript: s => s,\n          createScriptURL: s => s\n        });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy$1;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\nfunction trustedHTMLFromString(html) {\n  return getPolicy$1()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script) {\n  return getPolicy$1()?.createScript(script) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will cause a browser to load and execute a resource, e.g. when\n * assigning to script.src.\n */\nfunction trustedScriptURLFromString(url) {\n  return getPolicy$1()?.createScriptURL(url) || url;\n}\n/**\n * Unsafely call the Function constructor with the given string arguments. It\n * is only available in development mode, and should be stripped out of\n * production code.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from development code, as use in production code can lead to\n * XSS vulnerabilities.\n */\nfunction newTrustedFunctionForDev(...args) {\n  if (typeof ngDevMode === 'undefined') {\n    throw new Error('newTrustedFunctionForDev should never be called in production');\n  }\n  if (!_global.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = _global['eval'](trustedScriptFromString(body));\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(_global);\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n\n/**\n * Validation function invoked at runtime for each binding that might potentially\n * represent a security-sensitive attribute of an <iframe>.\n * See `IFRAME_SECURITY_SENSITIVE_ATTRS` in the\n * `packages/compiler/src/schema/dom_security_schema.ts` script for the full list\n * of such attributes.\n *\n * @codeGenApi\n */\nfunction ɵɵvalidateIframeAttribute(attrValue, tagName, attrName) {\n  const lView = getLView();\n  const tNode = getSelectedTNode();\n  const element = getNativeByTNode(tNode, lView);\n  // Restrict any dynamic bindings of security-sensitive attributes/properties\n  // on an <iframe> for security reasons.\n  if (tNode.type === 2 /* TNodeType.Element */ && tagName.toLowerCase() === 'iframe') {\n    const iframe = element;\n    // Unset previously applied `src` and `srcdoc` if we come across a situation when\n    // a security-sensitive attribute is set later via an attribute/property binding.\n    iframe.src = '';\n    iframe.srcdoc = trustedHTMLFromString('');\n    // Also remove the <iframe> from the document.\n    nativeRemoveNode(lView[RENDERER], iframe);\n    const errorMessage = ngDevMode && `Angular has detected that the \\`${attrName}\\` was applied ` + `as a binding to an <iframe>${getTemplateLocationDetails(lView)}. ` + `For security reasons, the \\`${attrName}\\` can be set on an <iframe> ` + `as a static attribute only. \\n` + `To fix this, switch the \\`${attrName}\\` binding to a static attribute ` + `in a template or in host bindings section.`;\n    throw new RuntimeError(-910 /* RuntimeErrorCode.UNSAFE_IFRAME_ATTRS */, errorMessage);\n  }\n  return attrValue;\n}\n\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser` and `Server`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\nlet DOCUMENT = undefined;\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nfunction setDocument(document) {\n  DOCUMENT = document;\n}\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\nfunction getDocument() {\n  if (DOCUMENT !== undefined) {\n    return DOCUMENT;\n  } else if (typeof document !== 'undefined') {\n    return document;\n  }\n  throw new RuntimeError(210 /* RuntimeErrorCode.MISSING_DOCUMENT */, (typeof ngDevMode === 'undefined' || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);\n  // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n  // the current platform is not a browser. Since this is not a supported scenario at the moment\n  // this should not happen in Angular apps.\n  // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n  // public API.\n}\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular specifically for bypassSecurityTrust* and custom sanitizers. It\n * lazily constructs the Trusted Types policy, providing helper utilities for\n * promoting strings to Trusted Types. When Trusted Types are not available,\n * strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n  if (policy === undefined) {\n    policy = null;\n    if (_global.trustedTypes) {\n      try {\n        policy = _global.trustedTypes.createPolicy('angular#unsafe-bypass', {\n          createHTML: s => s,\n          createScript: s => s,\n          createScriptURL: s => s\n        });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedHTMLFromStringBypass(html) {\n  return getPolicy()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptFromStringBypass(script) {\n  return getPolicy()?.createScript(script) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptURLFromStringBypass(url) {\n  return getPolicy()?.createScriptURL(url) || url;\n}\nclass SafeValueImpl {\n  constructor(changingThisBreaksApplicationSecurity) {\n    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n  }\n  toString() {\n    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + ` (see ${XSS_SECURITY_URL})`;\n  }\n}\nclass SafeHtmlImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"HTML\" /* BypassType.Html */;\n  }\n}\n\nclass SafeStyleImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"Style\" /* BypassType.Style */;\n  }\n}\n\nclass SafeScriptImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"Script\" /* BypassType.Script */;\n  }\n}\n\nclass SafeUrlImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"URL\" /* BypassType.Url */;\n  }\n}\n\nclass SafeResourceUrlImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"ResourceURL\" /* BypassType.ResourceUrl */;\n  }\n}\n\nfunction unwrapSafeValue(value) {\n  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;\n}\nfunction allowSanitizationBypassAndThrow(value, type) {\n  const actualType = getSanitizationBypassType(value);\n  if (actualType != null && actualType !== type) {\n    // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n    if (actualType === \"ResourceURL\" /* BypassType.ResourceUrl */ && type === \"URL\" /* BypassType.Url */) return true;\n    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);\n  }\n  return actualType === type;\n}\nfunction getSanitizationBypassType(value) {\n  return value instanceof SafeValueImpl && value.getTypeName() || null;\n}\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustHtml(trustedHtml) {\n  return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustStyle(trustedStyle) {\n  return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustScript(trustedScript) {\n  return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustUrl(trustedUrl) {\n  return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\n  return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n\n/**\n * This helper is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we use one of two strategies for doing this.\n * Default: DOMParser strategy\n * Fallback: InertDocument strategy\n */\nfunction getInertBodyHelper(defaultDoc) {\n  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);\n  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;\n}\n/**\n * Uses DOMParser to create and fill an inert body element.\n * This is the default strategy used in browsers that support it.\n */\nclass DOMParserHelper {\n  constructor(inertDocumentHelper) {\n    this.inertDocumentHelper = inertDocumentHelper;\n  }\n  getInertBodyElement(html) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag. Note that the `<body>` tag is closed implicitly to prevent unclosed tags\n    // in `html` from consuming the otherwise explicit `</body>` tag.\n    html = '<body><remove></remove>' + html;\n    try {\n      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), 'text/html').body;\n      if (body === null) {\n        // In some browsers (e.g. Mozilla/5.0 iPad AppleWebKit Mobile) the `body` property only\n        // becomes available in the following tick of the JS engine. In that case we fall back to\n        // the `inertDocumentHelper` instead.\n        return this.inertDocumentHelper.getInertBodyElement(html);\n      }\n      body.removeChild(body.firstChild);\n      return body;\n    } catch {\n      return null;\n    }\n  }\n}\n/**\n * Use an HTML5 `template` element to create and fill an inert DOM element.\n * This is the fallback strategy if the browser does not support DOMParser.\n */\nclass InertDocumentHelper {\n  constructor(defaultDoc) {\n    this.defaultDoc = defaultDoc;\n    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n  }\n  getInertBodyElement(html) {\n    const templateEl = this.inertDocument.createElement('template');\n    templateEl.innerHTML = trustedHTMLFromString(html);\n    return templateEl;\n  }\n}\n/**\n * We need to determine whether the DOMParser exists in the global context and\n * supports parsing HTML; HTML parsing support is not as wide as other formats, see\n * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser#Browser_compatibility.\n *\n * @suppress {uselessCode}\n */\nfunction isDOMParserAvailable() {\n  try {\n    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');\n  } catch {\n    return false;\n  }\n}\n\n/**\n * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\n * contexts.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if:\n * (1) Either a protocol that is not javascript:, and that has valid characters\n *     (alphanumeric or [+-.]).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\nconst SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\\/?#]*(?:[\\/?#]|$))/i;\nfunction _sanitizeUrl(url) {\n  url = String(url);\n  if (url.match(SAFE_URL_PATTERN)) return url;\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);\n  }\n  return 'unsafe:' + url;\n}\nfunction tagSet(tags) {\n  const res = {};\n  for (const t of tags.split(',')) res[t] = true;\n  return res;\n}\nfunction merge(...sets) {\n  const res = {};\n  for (const s of sets) {\n    for (const v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n  return res;\n}\n// Good source of info about elements and attributes\n// https://html.spec.whatwg.org/#semantics\n// https://simon.html5.org/html-elements\n// Safe Void Elements - HTML5\n// https://html.spec.whatwg.org/#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n// Elements that you can, intentionally, leave open (and which close themselves)\n// https://html.spec.whatwg.org/#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\nconst VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n// Attributes that have href and hence need to be sanitized\nconst URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\nconst HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width');\n// Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\nconst ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' + 'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' + 'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' + 'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' + 'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' + 'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' + 'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\nconst VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);\n// Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\n//\n// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\n// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\n// don't want to preserve the content, if the elements themselves are going to be removed.\nconst SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n  constructor() {\n    // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n    // because characters were re-encoded.\n    this.sanitizedSomething = false;\n    this.buf = [];\n  }\n  sanitizeChildren(el) {\n    // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n    // However this code never accesses properties off of `document` before deleting its contents\n    // again, so it shouldn't be vulnerable to DOM clobbering.\n    let current = el.firstChild;\n    let traverseContent = true;\n    while (current) {\n      if (current.nodeType === Node.ELEMENT_NODE) {\n        traverseContent = this.startElement(current);\n      } else if (current.nodeType === Node.TEXT_NODE) {\n        this.chars(current.nodeValue);\n      } else {\n        // Strip non-element, non-text nodes.\n        this.sanitizedSomething = true;\n      }\n      if (traverseContent && current.firstChild) {\n        current = current.firstChild;\n        continue;\n      }\n      while (current) {\n        // Leaving the element. Walk up and to the right, closing tags as we go.\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          this.endElement(current);\n        }\n        let next = this.checkClobberedElement(current, current.nextSibling);\n        if (next) {\n          current = next;\n          break;\n        }\n        current = this.checkClobberedElement(current, current.parentNode);\n      }\n    }\n    return this.buf.join('');\n  }\n  /**\n   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n   * be traversed. Element content must always be traversed (even if the element itself is not\n   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n   *\n   * @param element The element to sanitize.\n   * @return True if the element's contents should be traversed.\n   */\n  startElement(element) {\n    const tagName = element.nodeName.toLowerCase();\n    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.sanitizedSomething = true;\n      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n    }\n    this.buf.push('<');\n    this.buf.push(tagName);\n    const elAttrs = element.attributes;\n    for (let i = 0; i < elAttrs.length; i++) {\n      const elAttr = elAttrs.item(i);\n      const attrName = elAttr.name;\n      const lower = attrName.toLowerCase();\n      if (!VALID_ATTRS.hasOwnProperty(lower)) {\n        this.sanitizedSomething = true;\n        continue;\n      }\n      let value = elAttr.value;\n      // TODO(martinprobst): Special case image URIs for data:image/...\n      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);\n      this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n    }\n    this.buf.push('>');\n    return true;\n  }\n  endElement(current) {\n    const tagName = current.nodeName.toLowerCase();\n    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.buf.push('</');\n      this.buf.push(tagName);\n      this.buf.push('>');\n    }\n  }\n  chars(chars) {\n    this.buf.push(encodeEntities(chars));\n  }\n  checkClobberedElement(node, nextNode) {\n    if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);\n    }\n    return nextNode;\n  }\n}\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\nfunction encodeEntities(value) {\n  return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function (match) {\n    const hi = match.charCodeAt(0);\n    const low = match.charCodeAt(1);\n    return '&#' + ((hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000) + ';';\n  }).replace(NON_ALPHANUMERIC_REGEXP, function (match) {\n    return '&#' + match.charCodeAt(0) + ';';\n  }).replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\nlet inertBodyHelper;\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nfunction _sanitizeHtml(defaultDoc, unsafeHtmlInput) {\n  let inertBodyElement = null;\n  try {\n    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);\n    // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n    // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n    let mXSSAttempts = 5;\n    let parsedHtml = unsafeHtml;\n    do {\n      if (mXSSAttempts === 0) {\n        throw new Error('Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n      unsafeHtml = parsedHtml;\n      parsedHtml = inertBodyElement.innerHTML;\n      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    } while (unsafeHtml !== parsedHtml);\n    const sanitizer = new SanitizingHtmlSerializer();\n    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {\n      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);\n    }\n    return trustedHTMLFromString(safeHtml);\n  } finally {\n    // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n    if (inertBodyElement) {\n      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n      while (parent.firstChild) {\n        parent.removeChild(parent.firstChild);\n      }\n    }\n  }\n}\nfunction getTemplateContent(el) {\n  return 'content' in el /** Microsoft/TypeScript#21517 */ && isTemplateElement(el) ? el.content : null;\n}\nfunction isTemplateElement(el) {\n  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nvar SecurityContext;\n(function (SecurityContext) {\n  SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n  SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n  SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n  SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n  SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\n\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeHtml(unsafeHtml) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');\n  }\n  if (allowSanitizationBypassAndThrow(unsafeHtml, \"HTML\" /* BypassType.Html */)) {\n    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));\n  }\n  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));\n}\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeStyle(unsafeStyle) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeStyle, \"Style\" /* BypassType.Style */)) {\n    return unwrapSafeValue(unsafeStyle);\n  }\n  return renderStringify(unsafeStyle);\n}\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeUrl(unsafeUrl) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeUrl, \"URL\" /* BypassType.Url */)) {\n    return unwrapSafeValue(unsafeUrl);\n  }\n  return _sanitizeUrl(renderStringify(unsafeUrl));\n}\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeResourceUrl(unsafeResourceUrl) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '');\n  }\n  if (allowSanitizationBypassAndThrow(unsafeResourceUrl, \"ResourceURL\" /* BypassType.ResourceUrl */)) {\n    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));\n  }\n  throw new RuntimeError(904 /* RuntimeErrorCode.UNSAFE_VALUE_IN_RESOURCE_URL */, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);\n}\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link\n * bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts` have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeScript(unsafeScript) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '');\n  }\n  if (allowSanitizationBypassAndThrow(unsafeScript, \"Script\" /* BypassType.Script */)) {\n    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));\n  }\n  throw new RuntimeError(905 /* RuntimeErrorCode.UNSAFE_VALUE_IN_SCRIPT */, ngDevMode && 'unsafe value used in a script context');\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedHTML. Interpolation is explicitly not allowed.\n *\n * @param html constant template literal containing trusted HTML.\n * @returns TrustedHTML wrapping `html`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedHTML.\n *\n * @codeGenApi\n */\nfunction ɵɵtrustConstantHtml(html) {\n  // The following runtime check ensures that the function was called as a\n  // template tag (e.g. ɵɵtrustConstantHtml`content`), without any interpolation\n  // (e.g. not ɵɵtrustConstantHtml`content ${variable}`). A TemplateStringsArray\n  // is an array with a `raw` property that is also an array. The associated\n  // template literal has no interpolation if and only if the length of the\n  // TemplateStringsArray is 1.\n  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {\n    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);\n  }\n  return trustedHTMLFromString(html[0]);\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedScriptURL. Interpolation is explicitly not allowed.\n *\n * @param url constant template literal containing a trusted script URL.\n * @returns TrustedScriptURL wrapping `url`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedScriptURL.\n *\n * @codeGenApi\n */\nfunction ɵɵtrustConstantResourceUrl(url) {\n  // The following runtime check ensures that the function was called as a\n  // template tag (e.g. ɵɵtrustConstantResourceUrl`content`), without any\n  // interpolation (e.g. not ɵɵtrustConstantResourceUrl`content ${variable}`). A\n  // TemplateStringsArray is an array with a `raw` property that is also an\n  // array. The associated template literal has no interpolation if and only if\n  // the length of the TemplateStringsArray is 1.\n  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {\n    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);\n  }\n  return trustedScriptURLFromString(url[0]);\n}\n/**\n * Detects which sanitizer to use for URL property, based on tag name and prop name.\n *\n * The rules are based on the RESOURCE_URL context config from\n * `packages/compiler/src/schema/dom_security_schema.ts`.\n * If tag and prop names don't match Resource URL schema, use URL sanitizer.\n */\nfunction getUrlSanitizer(tag, prop) {\n  if (prop === 'src' && (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' || tag === 'script') || prop === 'href' && (tag === 'base' || tag === 'link')) {\n    return ɵɵsanitizeResourceUrl;\n  }\n  return ɵɵsanitizeUrl;\n}\n/**\n * Sanitizes URL, selecting sanitizer function based on tag and property names.\n *\n * This function is used in case we can't define security context at compile time, when only prop\n * name is available. This happens when we generate host bindings for Directives/Components. The\n * host element is unknown at compile time, so we defer calculation of specific sanitizer to\n * runtime.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @param tag target element tag name.\n * @param prop name of the property that contains the value.\n * @returns `url` string which is safe to bind.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {\n  return getUrlSanitizer(tag, prop)(unsafeUrl);\n}\nfunction validateAgainstEventProperties(name) {\n  if (name.toLowerCase().startsWith('on')) {\n    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...` + `\\nIf '${name}' is a directive input, make sure the directive is imported by the` + ` current module.`;\n    throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n  }\n}\nfunction validateAgainstEventAttributes(name) {\n  if (name.toLowerCase().startsWith('on')) {\n    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...`;\n    throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n  }\n}\nfunction getSanitizer() {\n  const lView = getLView();\n  return lView && lView[ENVIRONMENT].sanitizer;\n}\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * const myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the [`inject`](api/core/inject) function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule` (note:\n * this option is now deprecated). As mentioned above, `'root'` is the default value for\n * `providedIn`.\n *\n * The `providedIn: NgModule` and `providedIn: 'any'` options are deprecated.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\nclass InjectionToken {\n  /**\n   * @param _desc   Description for the token,\n   *                used only for debugging purposes,\n   *                it should but does not need to be unique\n   * @param options Options for the token's usage, as described above\n   */\n  constructor(_desc, options) {\n    this._desc = _desc;\n    /** @internal */\n    this.ngMetadataName = 'InjectionToken';\n    this.ɵprov = undefined;\n    if (typeof options == 'number') {\n      (typeof ngDevMode === 'undefined' || ngDevMode) && assertLessThan(options, 0, 'Only negative numbers are supported here');\n      // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n      // See `InjectorMarkers`\n      this.__NG_ELEMENT_ID__ = options;\n    } else if (options !== undefined) {\n      this.ɵprov = ɵɵdefineInjectable({\n        token: this,\n        providedIn: options.providedIn || 'root',\n        factory: options.factory\n      });\n    }\n  }\n  /**\n   * @internal\n   */\n  get multi() {\n    return this;\n  }\n  toString() {\n    return `InjectionToken ${this._desc}`;\n  }\n}\n\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @publicApi\n */\nconst ENVIRONMENT_INITIALIZER = new InjectionToken('ENVIRONMENT_INITIALIZER');\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nconst INJECTOR = new InjectionToken('INJECTOR',\n// Disable tslint because this is const enum which gets inlined not top level prop access.\n// tslint:disable-next-line: no-toplevel-property-access\n-1 /* InjectorMarkers.Injector */);\n\nconst INJECTOR_DEF_TYPES = new InjectionToken('INJECTOR_DEF_TYPES');\nclass NullInjector {\n  get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n      error.name = 'NullInjectorError';\n      throw error;\n    }\n    return notFoundValue;\n  }\n}\n\n/**\n * Wrap an array of `Provider`s into `EnvironmentProviders`, preventing them from being accidentally\n * referenced in `@Component` in a component injector.\n */\nfunction makeEnvironmentProviders(providers) {\n  return {\n    ɵproviders: providers\n  };\n}\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/standalone-components).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```typescript\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n */\nfunction importProvidersFrom(...sources) {\n  return {\n    ɵproviders: internalImportProvidersFrom(true, sources),\n    ɵfromNgModule: true\n  };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n  const providersOut = [];\n  const dedup = new Set(); // already seen types\n  let injectorTypesWithProviders;\n  deepForEach(sources, source => {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n      const cmpDef = getComponentDef(source);\n      if (cmpDef?.standalone) {\n        throw new RuntimeError(800 /* RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE */, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n      }\n    }\n    // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\n    const internalSource = source;\n    if (walkProviderTree(internalSource, providersOut, [], dedup)) {\n      injectorTypesWithProviders ||= [];\n      injectorTypesWithProviders.push(internalSource);\n    }\n  });\n  // Collect all providers from `ModuleWithProviders` types.\n  if (injectorTypesWithProviders !== undefined) {\n    processInjectorTypesWithProviders(injectorTypesWithProviders, providersOut);\n  }\n  return providersOut;\n}\n/**\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\n * array.\n */\nfunction processInjectorTypesWithProviders(typesWithProviders, providersOut) {\n  for (let i = 0; i < typesWithProviders.length; i++) {\n    const {\n      ngModule,\n      providers\n    } = typesWithProviders[i];\n    deepForEachProvider(providers, provider => {\n      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n      providersOut.push(provider);\n    });\n  }\n}\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\nfunction walkProviderTree(container, providersOut, parents, dedup) {\n  container = resolveForwardRef(container);\n  if (!container) return false;\n  // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n  // from `InjectorTypeWithProviders`.\n  let defType = null;\n  let injDef = getInjectorDef(container);\n  const cmpDef = !injDef && getComponentDef(container);\n  if (!injDef && !cmpDef) {\n    // `container` is not an injector type or a component type. It might be:\n    //  * An `InjectorTypeWithProviders` that wraps an injector type.\n    //  * A standalone directive or pipe that got pulled in from a standalone component's\n    //    dependencies.\n    // Try to unwrap it as an `InjectorTypeWithProviders` first.\n    const ngModule = container.ngModule;\n    injDef = getInjectorDef(ngModule);\n    if (injDef) {\n      defType = ngModule;\n    } else {\n      // Not a component or injector type, so ignore it.\n      return false;\n    }\n  } else if (cmpDef && !cmpDef.standalone) {\n    return false;\n  } else {\n    defType = container;\n  }\n  // Check for circular dependencies.\n  if (ngDevMode && parents.indexOf(defType) !== -1) {\n    const defName = stringify(defType);\n    const path = parents.map(stringify);\n    throwCyclicDependencyError(defName, path);\n  }\n  // Check for multiple imports of the same module\n  const isDuplicate = dedup.has(defType);\n  if (cmpDef) {\n    if (isDuplicate) {\n      // This component definition has already been processed.\n      return false;\n    }\n    dedup.add(defType);\n    if (cmpDef.dependencies) {\n      const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n      for (const dep of deps) {\n        walkProviderTree(dep, providersOut, parents, dedup);\n      }\n    }\n  } else if (injDef) {\n    // First, include providers from any imports.\n    if (injDef.imports != null && !isDuplicate) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      ngDevMode && parents.push(defType);\n      // Add it to the set of dedups. This way we can detect multiple imports of the same module\n      dedup.add(defType);\n      let importTypesWithProviders;\n      try {\n        deepForEach(injDef.imports, imported => {\n          if (walkProviderTree(imported, providersOut, parents, dedup)) {\n            importTypesWithProviders ||= [];\n            // If the processed import is an injector type with providers, we store it in the\n            // list of import types with providers, so that we can process those afterwards.\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        // Remove it from the parents set when finished.\n        ngDevMode && parents.pop();\n      }\n      // Imports which are declared with providers (TypeWithProviders) need to be processed\n      // after all imported modules are processed. This is similar to how View Engine\n      // processes/merges module imports in the metadata resolver. See: FW-1349.\n      if (importTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(importTypesWithProviders, providersOut);\n      }\n    }\n    if (!isDuplicate) {\n      // Track the InjectorType and add a provider for it.\n      // It's important that this is done after the def's imports.\n      const factory = getFactoryDef(defType) || (() => new defType());\n      // Append extra providers to make more info available for consumers (to retrieve an injector\n      // type), as well as internally (to calculate an injection scope correctly and eagerly\n      // instantiate a `defType` when an injector is created).\n      providersOut.push(\n      // Provider to create `defType` using its factory.\n      {\n        provide: defType,\n        useFactory: factory,\n        deps: EMPTY_ARRAY\n      },\n      // Make this `defType` available to an internal logic that calculates injector scope.\n      {\n        provide: INJECTOR_DEF_TYPES,\n        useValue: defType,\n        multi: true\n      },\n      // Provider to eagerly instantiate `defType` via `ENVIRONMENT_INITIALIZER`.\n      {\n        provide: ENVIRONMENT_INITIALIZER,\n        useValue: () => ɵɵinject(defType),\n        multi: true\n      } //\n      );\n    }\n    // Next, include providers listed on the definition itself.\n    const defProviders = injDef.providers;\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = container;\n      deepForEachProvider(defProviders, provider => {\n        ngDevMode && validateProvider(provider, defProviders, injectorType);\n        providersOut.push(provider);\n      });\n    }\n  } else {\n    // Should not happen, but just in case.\n    return false;\n  }\n  return defType !== container && container.providers !== undefined;\n}\nfunction validateProvider(provider, providers, containerType) {\n  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {\n    return;\n  }\n  // Here we expect the provider to be a `useClass` provider (by elimination).\n  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n  if (!classRef) {\n    throwInvalidProviderError(containerType, providers, provider);\n  }\n}\nfunction deepForEachProvider(providers, fn) {\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      deepForEachProvider(provider, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\nconst USE_VALUE$1 = getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\nfunction isValueProvider(value) {\n  return value !== null && typeof value == 'object' && USE_VALUE$1 in value;\n}\nfunction isExistingProvider(value) {\n  return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n  return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n  return typeof value === 'function';\n}\nfunction isClassProvider(value) {\n  return !!value.useClass;\n}\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nconst INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR$1 = undefined;\nfunction getNullInjector() {\n  if (NULL_INJECTOR$1 === undefined) {\n    NULL_INJECTOR$1 = new NullInjector();\n  }\n  return NULL_INJECTOR$1;\n}\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n */\nclass EnvironmentInjector {}\nclass R3Injector extends EnvironmentInjector {\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  get destroyed() {\n    return this._destroyed;\n  }\n  constructor(providers, parent, source, scopes) {\n    super();\n    this.parent = parent;\n    this.source = source;\n    this.scopes = scopes;\n    /**\n     * Map of tokens to records which contain the instances of those tokens.\n     * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n     * to prevent further searches.\n     */\n    this.records = new Map();\n    /**\n     * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n     */\n    this._ngOnDestroyHooks = new Set();\n    this._onDestroyHooks = [];\n    this._destroyed = false;\n    // Start off by creating Records for every provider.\n    forEachSingleProvider(providers, provider => this.processProvider(provider));\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n    // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n    if (scopes.has('environment')) {\n      this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n    }\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    const record = this.records.get(INJECTOR_SCOPE);\n    if (record != null && typeof record.value === 'string') {\n      this.scopes.add(record.value);\n    }\n    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));\n  }\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy() {\n    this.assertNotDestroyed();\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this._destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      for (const service of this._ngOnDestroyHooks) {\n        service.ngOnDestroy();\n      }\n      const onDestroyHooks = this._onDestroyHooks;\n      // Reset the _onDestroyHooks array before iterating over it to prevent hooks that unregister\n      // themselves from mutating the array during iteration.\n      this._onDestroyHooks = [];\n      for (const hook of onDestroyHooks) {\n        hook();\n      }\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this._ngOnDestroyHooks.clear();\n      this.injectorDefTypes.clear();\n    }\n  }\n  onDestroy(callback) {\n    this.assertNotDestroyed();\n    this._onDestroyHooks.push(callback);\n    return () => this.removeOnDestroy(callback);\n  }\n  runInContext(fn) {\n    this.assertNotDestroyed();\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      return fn();\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n  get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    this.assertNotDestroyed();\n    if (token.hasOwnProperty(NG_ENV_ID)) {\n      return token[NG_ENV_ID](this);\n    }\n    flags = convertToBitFlags(flags);\n    // Set the injection context.\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an injectable\n          // def with a scope matching this injector.\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n          this.records.set(token, record);\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record != null /* NOT null || undefined */) {\n          return this.hydrate(token, record);\n        }\n      }\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n      // is undefined, the value is null, otherwise it's the notFoundValue.\n      notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (e) {\n      if (e.name === 'NullInjectorError') {\n        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n        path.unshift(stringify(token));\n        if (previousInjector) {\n          // We still have a parent injector, keep throwing\n          throw e;\n        } else {\n          // Format & throw the final error message when we don't have any previous injector\n          return catchInjectorError(e, token, 'R3InjectorError', this.source);\n        }\n      } else {\n        throw e;\n      }\n    } finally {\n      // Lastly, restore the previous injection context.\n      setInjectImplementation(previousInjectImplementation);\n      setCurrentInjector(previousInjector);\n    }\n  }\n  /** @internal */\n  resolveInjectorInitializers() {\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);\n      if (ngDevMode && !Array.isArray(initializers)) {\n        throw new RuntimeError(-209 /* RuntimeErrorCode.INVALID_MULTI_PROVIDER */, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' + `(expected an array, but got ${typeof initializers}). ` + 'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' + '`multi: true` provider.');\n      }\n      for (const initializer of initializers) {\n        initializer();\n      }\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n  toString() {\n    const tokens = [];\n    const records = this.records;\n    for (const token of records.keys()) {\n      tokens.push(stringify(token));\n    }\n    return `R3Injector[${tokens.join(', ')}]`;\n  }\n  assertNotDestroyed() {\n    if (this._destroyed) {\n      throw new RuntimeError(205 /* RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED */, ngDevMode && 'Injector has already been destroyed.');\n    }\n  }\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  processProvider(provider) {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider);\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (ngDevMode && multiRecord.multi === undefined) {\n          throwMixedMultiProviderError();\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord.multi);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi.push(provider);\n    } else {\n      const existing = this.records.get(token);\n      if (ngDevMode && existing && existing.multi !== undefined) {\n        throwMixedMultiProviderError();\n      }\n    }\n    this.records.set(token, record);\n  }\n  hydrate(token, record) {\n    if (ngDevMode && record.value === CIRCULAR) {\n      throwCyclicDependencyError(stringify(token));\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      record.value = record.factory();\n    }\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this._ngOnDestroyHooks.add(record.value);\n    }\n    return record.value;\n  }\n  injectableDefInScope(def) {\n    if (!def.providedIn) {\n      return false;\n    }\n    const providedIn = resolveForwardRef(def.providedIn);\n    if (typeof providedIn === 'string') {\n      return providedIn === 'any' || this.scopes.has(providedIn);\n    } else {\n      return this.injectorDefTypes.has(providedIn);\n    }\n  }\n  removeOnDestroy(callback) {\n    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\n    if (destroyCBIdx !== -1) {\n      this._onDestroyHooks.splice(destroyCBIdx, 1);\n    }\n  }\n}\nfunction injectableDefOrInjectorDefFactory(token) {\n  // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n  const injectableDef = getInjectableDef(token);\n  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n  if (factory !== null) {\n    return factory;\n  }\n  // InjectionTokens should have an injectable def (ɵprov) and thus should be handled above.\n  // If it's missing that, it's an error.\n  if (token instanceof InjectionToken) {\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);\n  }\n  // Undecorated types can sometimes be created if they have no constructor arguments.\n  if (token instanceof Function) {\n    return getUndecoratedInjectableFactory(token);\n  }\n  // There was no way to resolve a factory for this token.\n  throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && 'unreachable');\n}\nfunction getUndecoratedInjectableFactory(token) {\n  // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n  const paramLength = token.length;\n  if (paramLength > 0) {\n    const args = newArray(paramLength, '?');\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);\n  }\n  // The constructor function appears to have no parameters.\n  // This might be because it inherits from a super-class. In which case, use an injectable\n  // def from an ancestor if there is one.\n  // Otherwise this really is a simple class with no dependencies, so return a factory that\n  // just instantiates the zero-arg constructor.\n  const inheritedInjectableDef = getInheritedInjectableDef(token);\n  if (inheritedInjectableDef !== null) {\n    return () => inheritedInjectableDef.factory(token);\n  } else {\n    return () => new token();\n  }\n}\nfunction providerToRecord(provider) {\n  if (isValueProvider(provider)) {\n    return makeRecord(undefined, provider.useValue);\n  } else {\n    const factory = providerToFactory(provider);\n    return makeRecord(factory, NOT_YET);\n  }\n}\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nfunction providerToFactory(provider, ngModuleType, providers) {\n  let factory = undefined;\n  if (ngDevMode && isEnvironmentProviders(provider)) {\n    throwInvalidProviderError(undefined, providers, provider);\n  }\n  if (isTypeProvider(provider)) {\n    const unwrappedProvider = resolveForwardRef(provider);\n    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else if (isExistingProvider(provider)) {\n      factory = () => ɵɵinject(resolveForwardRef(provider.useExisting));\n    } else {\n      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n      if (ngDevMode && !classRef) {\n        throwInvalidProviderError(ngModuleType, providers, provider);\n      }\n      if (hasDeps(provider)) {\n        factory = () => new classRef(...injectArgs(provider.deps));\n      } else {\n        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n      }\n    }\n  }\n  return factory;\n}\nfunction makeRecord(factory, value, multi = false) {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined\n  };\n}\nfunction hasDeps(value) {\n  return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n  return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';\n}\nfunction couldBeInjectableType(value) {\n  return typeof value === 'function' || typeof value === 'object' && value instanceof InjectionToken;\n}\nfunction forEachSingleProvider(providers, fn) {\n  for (const provider of providers) {\n    if (Array.isArray(provider)) {\n      forEachSingleProvider(provider, fn);\n    } else if (provider && isEnvironmentProviders(provider)) {\n      forEachSingleProvider(provider.ɵproviders, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") representing a string ID, used\n * primarily for prefixing application attributes and CSS styles when\n * {@link ViewEncapsulation#Emulated} is being used.\n *\n * The token is needed in cases when multiple applications are bootstrapped on a page\n * (for example, using `bootstrapApplication` calls). In this case, ensure that those applications\n * have different `APP_ID` value setup. For example:\n *\n * ```\n * bootstrapApplication(ComponentA, {\n *   providers: [\n *     { provide: APP_ID, useValue: 'app-a' },\n *     // ... other providers ...\n *   ]\n * });\n *\n * bootstrapApplication(ComponentB, {\n *   providers: [\n *     { provide: APP_ID, useValue: 'app-b' },\n *     // ... other providers ...\n *   ]\n * });\n * ```\n *\n * By default, when there is only one application bootstrapped, you don't need to provide the\n * `APP_ID` token (the `ng` will be used as an app ID).\n *\n * @publicApi\n */\nconst APP_ID = new InjectionToken('AppId', {\n  providedIn: 'root',\n  factory: () => DEFAULT_APP_ID\n});\n/** Default value of the `APP_ID` token. */\nconst DEFAULT_APP_ID = 'ng';\n/**\n * A function that is executed when a platform is initialized.\n * @publicApi\n */\nconst PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');\n/**\n * A token that indicates an opaque platform ID.\n * @publicApi\n */\nconst PLATFORM_ID = new InjectionToken('Platform ID', {\n  providedIn: 'platform',\n  factory: () => 'unknown' // set a default platform name, when none set explicitly\n});\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates the root directory of\n * the application\n * @publicApi\n */\nconst PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');\n// We keep this token here, rather than the animations package, so that modules that only care\n// about which animations module is loaded (e.g. the CDK) can retrieve it without having to\n// include extra dependencies. See #44970 for more context.\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates which animations\n * module has been loaded.\n * @publicApi\n */\nconst ANIMATION_MODULE_TYPE = new InjectionToken('AnimationModuleType');\n// TODO(crisbeto): link to CSP guide here.\n/**\n * Token used to configure the [Content Security Policy](https://web.dev/strict-csp/) nonce that\n * Angular will apply when inserting inline styles. If not provided, Angular will look up its value\n * from the `ngCspNonce` attribute of the application root node.\n *\n * @publicApi\n */\nconst CSP_NONCE = new InjectionToken('CSP nonce', {\n  providedIn: 'root',\n  factory: () => {\n    // Ideally we wouldn't have to use `querySelector` here since we know that the nonce will be on\n    // the root node, but because the token value is used in renderers, it has to be available\n    // *very* early in the bootstrapping process. This should be a fairly shallow search, because\n    // the app won't have been added to the DOM yet. Some approaches that were considered:\n    // 1. Find the root node through `ApplicationRef.components[i].location` - normally this would\n    // be enough for our purposes, but the token is injected very early so the `components` array\n    // isn't populated yet.\n    // 2. Find the root `LView` through the current `LView` - renderers are a prerequisite to\n    // creating the `LView`. This means that no `LView` will have been entered when this factory is\n    // invoked for the root component.\n    // 3. Have the token factory return `() => string` which is invoked when a nonce is requested -\n    // the slightly later execution does allow us to get an `LView` reference, but the fact that\n    // it is a function means that it could be executed at *any* time (including immediately) which\n    // may lead to weird bugs.\n    // 4. Have the `ComponentFactory` read the attribute and provide it to the injector under the\n    // hood - has the same problem as #1 and #2 in that the renderer is used to query for the root\n    // node and the nonce value needs to be available when the renderer is created.\n    return getDocument().body?.querySelector('[ngCspNonce]')?.getAttribute('ngCspNonce') || null;\n  }\n});\n/**\n * Internal token to collect all SSR-related features enabled for this application.\n *\n * Note: the token is in `core` to let other packages register features (the `core`\n * package is imported in other packages).\n */\nconst ENABLED_SSR_FEATURES = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'ENABLED_SSR_FEATURES' : '', {\n  providedIn: 'root',\n  factory: () => new Set()\n});\n\n/**\n * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.\n *\n * Example:\n *\n * ```\n * const COUNTER_KEY = makeStateKey<number>('counter');\n * let value = 10;\n *\n * transferState.set(COUNTER_KEY, value);\n * ```\n *\n * @publicApi\n */\nfunction makeStateKey(key) {\n  return key;\n}\nfunction initTransferState() {\n  const transferState = new TransferState();\n  if (inject(PLATFORM_ID) === 'browser') {\n    transferState.store = retrieveTransferredState(getDocument(), inject(APP_ID));\n  }\n  return transferState;\n}\n/**\n * A key value store that is transferred from the application on the server side to the application\n * on the client side.\n *\n * The `TransferState` is available as an injectable token.\n * On the client, just inject this token using DI and use it, it will be lazily initialized.\n * On the server it's already included if `renderApplication` function is used. Otherwise, import\n * the `ServerTransferStateModule` module to make the `TransferState` available.\n *\n * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only\n * boolean, number, string, null and non-class objects will be serialized and deserialized in a\n * non-lossy manner.\n *\n * @publicApi\n */\nclass TransferState {\n  constructor() {\n    /** @internal */\n    this.store = {};\n    this.onSerializeCallbacks = {};\n  }\n  /** @nocollapse */\n\n  /**\n   * Get the value corresponding to a key. Return `defaultValue` if key is not found.\n   */\n  get(key, defaultValue) {\n    return this.store[key] !== undefined ? this.store[key] : defaultValue;\n  }\n  /**\n   * Set the value corresponding to a key.\n   */\n  set(key, value) {\n    this.store[key] = value;\n  }\n  /**\n   * Remove a key from the store.\n   */\n  remove(key) {\n    delete this.store[key];\n  }\n  /**\n   * Test whether a key exists in the store.\n   */\n  hasKey(key) {\n    return this.store.hasOwnProperty(key);\n  }\n  /**\n   * Indicates whether the state is empty.\n   */\n  get isEmpty() {\n    return Object.keys(this.store).length === 0;\n  }\n  /**\n   * Register a callback to provide the value for a key when `toJson` is called.\n   */\n  onSerialize(key, callback) {\n    this.onSerializeCallbacks[key] = callback;\n  }\n  /**\n   * Serialize the current state of the store to JSON.\n   */\n  toJson() {\n    // Call the onSerialize callbacks and put those values into the store.\n    for (const key in this.onSerializeCallbacks) {\n      if (this.onSerializeCallbacks.hasOwnProperty(key)) {\n        try {\n          this.store[key] = this.onSerializeCallbacks[key]();\n        } catch (e) {\n          console.warn('Exception in onSerialize callback: ', e);\n        }\n      }\n    }\n    // Escape script tag to avoid break out of <script> tag in serialized output.\n    // Encoding of `<` is the same behaviour as G3 script_builders.\n    return JSON.stringify(this.store).replace(/</g, '\\\\u003C');\n  }\n}\nTransferState.ɵprov = /** @pureOrBreakMyCode */ɵɵdefineInjectable({\n  token: TransferState,\n  providedIn: 'root',\n  factory: initTransferState\n});\nfunction retrieveTransferredState(doc, appId) {\n  // Locate the script tag with the JSON data transferred from the server.\n  // The id of the script tag is set to the Angular appId + 'state'.\n  const script = doc.getElementById(appId + '-state');\n  if (script?.textContent) {\n    try {\n      // Avoid using any here as it triggers lint errors in google3 (any is not allowed).\n      // Decoding of `<` is done of the box by browsers and node.js, same behaviour as G3\n      // script_builders.\n      return JSON.parse(script.textContent);\n    } catch (e) {\n      console.warn('Exception while restoring TransferState for app ' + appId, e);\n    }\n  }\n  return {};\n}\n\n/** Encodes that the node lookup should start from the host node of this component. */\nconst REFERENCE_NODE_HOST = 'h';\n/** Encodes that the node lookup should start from the document body node. */\nconst REFERENCE_NODE_BODY = 'b';\n/**\n * Describes navigation steps that the runtime logic need to perform,\n * starting from a given (known) element.\n */\nvar NodeNavigationStep;\n(function (NodeNavigationStep) {\n  NodeNavigationStep[\"FirstChild\"] = \"f\";\n  NodeNavigationStep[\"NextSibling\"] = \"n\";\n})(NodeNavigationStep || (NodeNavigationStep = {}));\n/**\n * Keys within serialized view data structure to represent various\n * parts. See the `SerializedView` interface below for additional information.\n */\nconst ELEMENT_CONTAINERS = 'e';\nconst TEMPLATES = 't';\nconst CONTAINERS = 'c';\nconst MULTIPLIER = 'x';\nconst NUM_ROOT_NODES = 'r';\nconst TEMPLATE_ID = 'i'; // as it's also an \"id\"\nconst NODES = 'n';\nconst DISCONNECTED_NODES = 'd';\n\n/**\n * The name of the key used in the TransferState collection,\n * where hydration information is located.\n */\nconst TRANSFER_STATE_TOKEN_ID = '__ɵnghData__';\n/**\n * Lookup key used to reference DOM hydration data (ngh) in `TransferState`.\n */\nconst NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);\n/**\n * The name of the attribute that would be added to host component\n * nodes and contain a reference to a particular slot in transferred\n * state that contains the necessary hydration info for this component.\n */\nconst NGH_ATTR_NAME = 'ngh';\n/**\n * Reference to a function that reads `ngh` attribute value from a given RNode\n * and retrieves hydration information from the TransferState using that value\n * as an index. Returns `null` by default, when hydration is not enabled.\n *\n * @param rNode Component's host element.\n * @param injector Injector that this component has access to.\n */\nlet _retrieveHydrationInfoImpl = (rNode, injector) => null;\nfunction retrieveHydrationInfoImpl(rNode, injector) {\n  const nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);\n  if (nghAttrValue == null) return null;\n  let data = {};\n  // An element might have an empty `ngh` attribute value (e.g. `<comp ngh=\"\" />`),\n  // which means that no special annotations are required. Do not attempt to read\n  // from the TransferState in this case.\n  if (nghAttrValue !== '') {\n    const transferState = injector.get(TransferState, null, {\n      optional: true\n    });\n    if (transferState !== null) {\n      const nghData = transferState.get(NGH_DATA_KEY, []);\n      // The nghAttrValue is always a number referencing an index\n      // in the hydration TransferState data.\n      data = nghData[Number(nghAttrValue)];\n      // If the `ngh` attribute exists and has a non-empty value,\n      // the hydration info *must* be present in the TransferState.\n      // If there is no data for some reasons, this is an error.\n      ngDevMode && assertDefined(data, 'Unable to retrieve hydration info from the TransferState.');\n    }\n  }\n  const dehydratedView = {\n    data,\n    firstChild: rNode.firstChild ?? null\n  };\n  // The `ngh` attribute is cleared from the DOM node now\n  // that the data has been retrieved.\n  rNode.removeAttribute(NGH_ATTR_NAME);\n  // Note: don't check whether this node was claimed for hydration,\n  // because this node might've been previously claimed while processing\n  // template instructions.\n  ngDevMode && markRNodeAsClaimedByHydration(rNode, /* checkIfAlreadyClaimed */false);\n  ngDevMode && ngDevMode.hydratedComponents++;\n  return dehydratedView;\n}\n/**\n * Sets the implementation for the `retrieveHydrationInfo` function.\n */\nfunction enableRetrieveHydrationInfoImpl() {\n  _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;\n}\n/**\n * Retrieves hydration info by reading the value from the `ngh` attribute\n * and accessing a corresponding slot in TransferState storage.\n */\nfunction retrieveHydrationInfo(rNode, injector) {\n  return _retrieveHydrationInfoImpl(rNode, injector);\n}\n/**\n * Retrieves an instance of a component LView from a given ViewRef.\n * Returns an instance of a component LView or `null` in case of an embedded view.\n */\nfunction getComponentLViewForHydration(viewRef) {\n  // Reading an internal field from `ViewRef` instance.\n  let lView = viewRef._lView;\n  const tView = lView[TVIEW];\n  // A registered ViewRef might represent an instance of an\n  // embedded view, in which case we do not need to annotate it.\n  if (tView.type === 2 /* TViewType.Embedded */) {\n    return null;\n  }\n  // Check if it's a root view and if so, retrieve component's\n  // LView from the first slot after the header.\n  if (isRootView(lView)) {\n    lView = lView[HEADER_OFFSET];\n  }\n  // If a `ViewContainerRef` was injected in a component class, this resulted\n  // in an LContainer creation at that location. In this case, the component\n  // LView is in the LContainer's `HOST` slot.\n  if (isLContainer(lView)) {\n    lView = lView[HOST];\n  }\n  return lView;\n}\nfunction getTextNodeContent(node) {\n  return node.textContent?.replace(/\\s/gm, '');\n}\n/**\n * Restores text nodes and separators into the DOM that were lost during SSR\n * serialization. The hydration process replaces empty text nodes and text\n * nodes that are immediately adjacent to other text nodes with comment nodes\n * that this method filters on to restore those missing nodes that the\n * hydration process is expecting to be present.\n *\n * @param node The app's root HTML Element\n */\nfunction processTextNodeMarkersBeforeHydration(node) {\n  const doc = getDocument();\n  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n    acceptNode(node) {\n      const content = getTextNodeContent(node);\n      const isTextNodeMarker = content === \"ngetn\" /* TextNodeMarker.EmptyNode */ || content === \"ngtns\" /* TextNodeMarker.Separator */;\n      return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n    }\n  });\n  let currentNode;\n  // We cannot modify the DOM while using the commentIterator,\n  // because it throws off the iterator state.\n  // So we collect all marker nodes first and then follow up with\n  // applying the changes to the DOM: either inserting an empty node\n  // or just removing the marker if it was used as a separator.\n  const nodes = [];\n  while (currentNode = commentNodesIterator.nextNode()) {\n    nodes.push(currentNode);\n  }\n  for (const node of nodes) {\n    if (node.textContent === \"ngetn\" /* TextNodeMarker.EmptyNode */) {\n      node.replaceWith(doc.createTextNode(''));\n    } else {\n      node.remove();\n    }\n  }\n}\n/**\n * Marks a node as \"claimed\" by hydration process.\n * This is needed to make assessments in tests whether\n * the hydration process handled all nodes.\n */\nfunction markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {\n  if (!ngDevMode) {\n    throw new Error('Calling `markRNodeAsClaimedByHydration` in prod mode ' + 'is not supported and likely a mistake.');\n  }\n  if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {\n    throw new Error('Trying to claim a node, which was claimed already.');\n  }\n  node.__claimed = true;\n  ngDevMode.hydratedNodes++;\n}\nfunction isRNodeClaimedForHydration(node) {\n  return !!node.__claimed;\n}\nfunction setSegmentHead(hydrationInfo, index, node) {\n  hydrationInfo.segmentHeads ??= {};\n  hydrationInfo.segmentHeads[index] = node;\n}\nfunction getSegmentHead(hydrationInfo, index) {\n  return hydrationInfo.segmentHeads?.[index] ?? null;\n}\n/**\n * Returns the size of an <ng-container>, using either the information\n * serialized in `ELEMENT_CONTAINERS` (element container size) or by\n * computing the sum of root nodes in all dehydrated views in a given\n * container (in case this `<ng-container>` was also used as a view\n * container host node, e.g. <ng-container *ngIf>).\n */\nfunction getNgContainerSize(hydrationInfo, index) {\n  const data = hydrationInfo.data;\n  let size = data[ELEMENT_CONTAINERS]?.[index] ?? null;\n  // If there is no serialized information available in the `ELEMENT_CONTAINERS` slot,\n  // check if we have info about view containers at this location (e.g.\n  // `<ng-container *ngIf>`) and use container size as a number of root nodes in this\n  // element container.\n  if (size === null && data[CONTAINERS]?.[index]) {\n    size = calcSerializedContainerSize(hydrationInfo, index);\n  }\n  return size;\n}\nfunction getSerializedContainerViews(hydrationInfo, index) {\n  return hydrationInfo.data[CONTAINERS]?.[index] ?? null;\n}\n/**\n * Computes the size of a serialized container (the number of root nodes)\n * by calculating the sum of root nodes in all dehydrated views in this container.\n */\nfunction calcSerializedContainerSize(hydrationInfo, index) {\n  const views = getSerializedContainerViews(hydrationInfo, index) ?? [];\n  let numNodes = 0;\n  for (let view of views) {\n    numNodes += view[NUM_ROOT_NODES] * (view[MULTIPLIER] ?? 1);\n  }\n  return numNodes;\n}\n/**\n * Checks whether a node is annotated as \"disconnected\", i.e. not present\n * in the DOM at serialization time. We should not attempt hydration for\n * such nodes and instead, use a regular \"creation mode\".\n */\nfunction isDisconnectedNode$1(hydrationInfo, index) {\n  // Check if we are processing disconnected info for the first time.\n  if (typeof hydrationInfo.disconnectedNodes === 'undefined') {\n    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];\n    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;\n  }\n  return !!hydrationInfo.disconnectedNodes?.has(index);\n}\n\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\nclass ComponentRef$1 {}\n/**\n * Base class for a factory that can create a component dynamically.\n * Instantiate a factory for a given type of component with `resolveComponentFactory()`.\n * Use the resulting `ComponentFactory.create()` method to create a component of that type.\n *\n * @see [Dynamic Components](guide/dynamic-component-loader)\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactory$1 {}\nfunction noComponentFactoryError(component) {\n  const error = Error(`No component factory found for ${stringify(component)}.`);\n  error[ERROR_COMPONENT] = component;\n  return error;\n}\nconst ERROR_COMPONENT = 'ngComponent';\nfunction getComponent$1(error) {\n  return error[ERROR_COMPONENT];\n}\nclass _NullComponentFactoryResolver {\n  resolveComponentFactory(component) {\n    throw noComponentFactoryError(component);\n  }\n}\n/**\n * A simple registry that maps `Components` to generated `ComponentFactory` classes\n * that can be used to create instances of components.\n * Use to obtain the factory for a given component type,\n * then use the factory's `create()` method to create a component of that type.\n *\n * Note: since v13, dynamic component creation via\n * [`ViewContainerRef.createComponent`](api/core/ViewContainerRef#createComponent)\n * does **not** require resolving component factory: component class can be used directly.\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactoryResolver$1 {}\n\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nComponentFactoryResolver$1.NULL = /* @__PURE__ */new _NullComponentFactoryResolver();\nfunction injectElementRef() {\n  return createElementRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates an ElementRef given a node.\n *\n * @param tNode The node for which you'd like an ElementRef\n * @param lView The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nfunction createElementRef(tNode, lView) {\n  return new ElementRef(getNativeByTNode(tNode, lView));\n}\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nclass ElementRef {\n  constructor(nativeElement) {\n    this.nativeElement = nativeElement;\n  }\n  /**\n   * @internal\n   * @nocollapse\n   */\n}\n/**\n * Unwraps `ElementRef` and return the `nativeElement`.\n *\n * @param value value to unwrap\n * @returns `nativeElement` if `ElementRef` otherwise returns value as is.\n */\nElementRef.__NG_ELEMENT_ID__ = injectElementRef;\nfunction unwrapElementRef(value) {\n  return value instanceof ElementRef ? value.nativeElement : value;\n}\n\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\nclass RendererFactory2 {}\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\nclass Renderer2 {\n  constructor() {\n    /**\n     * If null or undefined, the view engine won't call it.\n     * This is used as a performance optimization for production mode.\n     */\n    this.destroyNode = null;\n  }\n  /**\n   * @internal\n   * @nocollapse\n   */\n}\n/** Injects a Renderer2 for the current component. */\nRenderer2.__NG_ELEMENT_ID__ = () => injectRenderer2();\nfunction injectRenderer2() {\n  // We need the Renderer to be based on the component that it's being injected into, however since\n  // DI happens before we've entered its view, `getLView` will return the parent view instead.\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);\n  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];\n}\n\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\nclass Sanitizer {}\n\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\n/** @nocollapse */\nSanitizer.ɵprov = ɵɵdefineInjectable({\n  token: Sanitizer,\n  providedIn: 'root',\n  factory: () => null\n});\nclass Version {\n  constructor(full) {\n    this.full = full;\n    this.major = full.split('.')[0];\n    this.minor = full.split('.')[1];\n    this.patch = full.split('.').slice(2).join('.');\n  }\n}\n/**\n * @publicApi\n */\nconst VERSION = new Version('16.1.6');\n\n// This default value is when checking the hierarchy for a token.\n//\n// It means both:\n// - the token is not provided by the current injector,\n// - only the element injectors should be checked (ie do not check module injectors\n//\n//          mod1\n//         /\n//       el1   mod2\n//         \\  /\n//         el2\n//\n// When requesting el2.injector.get(token), we should check in the following order and return the\n// first found value:\n// - el2.injector.get(token, default)\n// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\n// - mod2.injector.get(token, default)\nconst NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\n\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nfunction markViewDirty(lView) {\n  while (lView) {\n    lView[FLAGS] |= 64 /* LViewFlags.Dirty */;\n    const parent = getLViewParent(lView);\n    // Stop traversing up as soon as you find a root view that wasn't attached to any container\n    if (isRootView(lView) && !parent) {\n      return lView;\n    }\n    // continue otherwise\n    lView = parent;\n  }\n  return null;\n}\nconst ERROR_ORIGINAL_ERROR = 'ngOriginalError';\nfunction wrappedError(message, originalError) {\n  const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;\n  const error = Error(msg);\n  error[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\nfunction getOriginalError(error) {\n  return error[ERROR_ORIGINAL_ERROR];\n}\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nclass ErrorHandler {\n  constructor() {\n    /**\n     * @internal\n     */\n    this._console = console;\n  }\n  handleError(error) {\n    const originalError = this._findOriginalError(error);\n    this._console.error('ERROR', error);\n    if (originalError) {\n      this._console.error('ORIGINAL ERROR', originalError);\n    }\n  }\n  /** @internal */\n  _findOriginalError(error) {\n    let e = error && getOriginalError(error);\n    while (e && getOriginalError(e)) {\n      e = getOriginalError(e);\n    }\n    return e || null;\n  }\n}\n\n/**\n * Internal token that specifies whether DOM reuse logic\n * during hydration is enabled.\n */\nconst IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'IS_HYDRATION_DOM_REUSE_ENABLED' : '');\n// By default (in client rendering mode), we remove all the contents\n// of the host element and render an application after that.\nconst PRESERVE_HOST_CONTENT_DEFAULT = false;\n/**\n * Internal token that indicates whether host element content should be\n * retained during the bootstrap.\n */\nconst PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'PRESERVE_HOST_CONTENT' : '', {\n  providedIn: 'root',\n  factory: () => PRESERVE_HOST_CONTENT_DEFAULT\n});\nfunction normalizeDebugBindingName(name) {\n  // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\n  name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\n  return `ng-reflect-${name}`;\n}\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\nfunction camelCaseToDashCase(input) {\n  return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());\n}\nfunction normalizeDebugBindingValue(value) {\n  try {\n    // Limit the size of the value as otherwise the DOM just gets polluted.\n    return value != null ? value.toString().slice(0, 30) : value;\n  } catch (e) {\n    return '[ERROR] Exception while trying to serialize the value';\n  }\n}\n\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveWindow(element) {\n  return element.ownerDocument.defaultView;\n}\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveDocument(element) {\n  return element.ownerDocument;\n}\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveBody(element) {\n  return element.ownerDocument.body;\n}\n/**\n * The special delimiter we use to separate property names, prefixes, and suffixes\n * in property binding metadata. See storeBindingMetadata().\n *\n * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\n * because it is a very uncommon character that is unlikely to be part of a user's\n * property names or interpolation strings. If it is in fact used in a property\n * binding, DebugElement.properties will not return the correct value for that\n * binding. However, there should be no runtime effect for real applications.\n *\n * This character is typically rendered as a question mark inside of a diamond.\n * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\n *\n */\nconst INTERPOLATION_DELIMITER = `�`;\n/**\n * Unwrap a value which might be behind a closure (for forward declaration reasons).\n */\nfunction maybeUnwrapFn(value) {\n  if (value instanceof Function) {\n    return value();\n  } else {\n    return value;\n  }\n}\n\n/**\n * The max length of the string representation of a value in an error message\n */\nconst VALUE_STRING_LENGTH_LIMIT = 200;\n/** Verifies that a given type is a Standalone Component. */\nfunction assertStandaloneComponentType(type) {\n  assertComponentDef(type);\n  const componentDef = getComponentDef(type);\n  if (!componentDef.standalone) {\n    throw new RuntimeError(907 /* RuntimeErrorCode.TYPE_IS_NOT_STANDALONE */, `The ${stringifyForError(type)} component is not marked as standalone, ` + `but Angular expects to have a standalone component here. ` + `Please make sure the ${stringifyForError(type)} component has ` + `the \\`standalone: true\\` flag in the decorator.`);\n  }\n}\n/** Verifies whether a given type is a component */\nfunction assertComponentDef(type) {\n  if (!getComponentDef(type)) {\n    throw new RuntimeError(906 /* RuntimeErrorCode.MISSING_GENERATED_DEF */, `The ${stringifyForError(type)} is not an Angular component, ` + `make sure it has the \\`@Component\\` decorator.`);\n  }\n}\n/** Called when there are multiple component selectors that match a given node */\nfunction throwMultipleComponentError(tNode, first, second) {\n  throw new RuntimeError(-300 /* RuntimeErrorCode.MULTIPLE_COMPONENTS_MATCH */, `Multiple components match node with tagname ${tNode.value}: ` + `${stringifyForError(first)} and ` + `${stringifyForError(second)}`);\n}\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\nfunction throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {\n  const hostComponentDef = getDeclarationComponentDef(lView);\n  const componentClassName = hostComponentDef?.type?.name;\n  const field = propName ? ` for '${propName}'` : '';\n  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ''}`;\n  if (creationMode) {\n    msg += ` It seems like the view has been created after its parent and its children have been dirty checked.` + ` Has it been created in a change detection hook?`;\n  }\n  throw new RuntimeError(-100 /* RuntimeErrorCode.EXPRESSION_CHANGED_AFTER_CHECKED */, msg);\n}\nfunction formatValue(value) {\n  let strValue = String(value);\n  // JSON.stringify will throw on circular references\n  try {\n    if (Array.isArray(value) || strValue === '[object Object]') {\n      strValue = JSON.stringify(value);\n    }\n  } catch (error) {}\n  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + '…' : strValue;\n}\nfunction constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {\n  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);\n  let oldValue = prefix,\n    newValue = prefix;\n  for (let i = 0; i < chunks.length; i++) {\n    const slotIdx = rootIndex + i;\n    oldValue += `${lView[slotIdx]}${chunks[i]}`;\n    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;\n  }\n  return {\n    propName,\n    oldValue,\n    newValue\n  };\n}\n/**\n * Constructs an object that contains details for the ExpressionChangedAfterItHasBeenCheckedError:\n * - property name (for property bindings or interpolations)\n * - old and new values, enriched using information from metadata\n *\n * More information on the metadata storage format can be found in `storePropertyBindingMetadata`\n * function description.\n */\nfunction getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {\n  const tData = lView[TVIEW].data;\n  const metadata = tData[bindingIndex];\n  if (typeof metadata === 'string') {\n    // metadata for property interpolation\n    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {\n      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);\n    }\n    // metadata for property binding\n    return {\n      propName: metadata,\n      oldValue,\n      newValue\n    };\n  }\n  // metadata is not available for this expression, check if this expression is a part of the\n  // property interpolation by going from the current binding index left and look for a string that\n  // contains INTERPOLATION_DELIMITER, the layout in tView.data for this case will look like this:\n  // [..., 'id�Prefix � and � suffix', null, null, null, ...]\n  if (metadata === null) {\n    let idx = bindingIndex - 1;\n    while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {\n      idx--;\n    }\n    const meta = tData[idx];\n    if (typeof meta === 'string') {\n      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));\n      // first interpolation delimiter separates property name from interpolation parts (in case of\n      // property interpolations), so we subtract one from total number of found delimiters\n      if (matches && matches.length - 1 > bindingIndex - idx) {\n        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);\n      }\n    }\n  }\n  return {\n    propName: undefined,\n    oldValue,\n    newValue\n  };\n}\nclass ReactiveLViewConsumer extends ReactiveNode {\n  constructor() {\n    super(...arguments);\n    this.consumerAllowSignalWrites = false;\n    this._lView = null;\n  }\n  set lView(lView) {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && assertEqual(this._lView, null, 'Consumer already associated with a view.');\n    this._lView = lView;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && assertDefined(this._lView, 'Updating a signal during template or host binding execution is not allowed.');\n    markViewDirty(this._lView);\n  }\n  onProducerUpdateValueVersion() {\n    // This type doesn't implement the producer side of a `ReactiveNode`.\n  }\n  get hasReadASignal() {\n    return this.hasProducers;\n  }\n  runInContext(fn, rf, ctx) {\n    const prevConsumer = setActiveConsumer(this);\n    this.trackingVersion++;\n    try {\n      fn(rf, ctx);\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  destroy() {\n    // Incrementing the version means that every producer which tries to update this consumer will\n    // consider its record stale, and not notify.\n    this.trackingVersion++;\n  }\n}\nlet currentConsumer = null;\nfunction getOrCreateCurrentLViewConsumer() {\n  currentConsumer ??= new ReactiveLViewConsumer();\n  return currentConsumer;\n}\n/**\n * Create a new template consumer pointing at the specified LView.\n * Sometimes, a previously created consumer may be reused, in order to save on allocations. In that\n * case, the LView will be updated.\n */\nfunction getReactiveLViewConsumer(lView, slot) {\n  return lView[slot] ?? getOrCreateCurrentLViewConsumer();\n}\n/**\n * Assigns the `currentTemplateContext` to its LView's `REACTIVE_CONSUMER` slot if there are tracked\n * producers.\n *\n * The presence of producers means that a signal was read while the consumer was the active\n * consumer.\n *\n * If no producers are present, we do not assign the current template context. This also means we\n * can just reuse the template context for the next LView.\n */\nfunction commitLViewConsumerIfHasProducers(lView, slot) {\n  const consumer = getOrCreateCurrentLViewConsumer();\n  if (!consumer.hasReadASignal) {\n    return;\n  }\n  lView[slot] = currentConsumer;\n  consumer.lView = lView;\n  currentConsumer = new ReactiveLViewConsumer();\n}\n\n/** A special value which designates that a value has not changed. */\nconst NO_CHANGE = typeof ngDevMode === 'undefined' || ngDevMode ? {\n  __brand__: 'NO_CHANGE'\n} : {};\n\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n *   if (rf & 1) {\n *     text(0, 'Hello');\n *     text(1, 'Goodbye')\n *     element(2, 'div');\n *   }\n *   if (rf & 2) {\n *     advance(2); // Advance twice to the <div>.\n *     property('title', 'test');\n *   }\n *  }\n * ```\n * @param delta Number of elements to advance forwards by.\n *\n * @codeGenApi\n */\nfunction ɵɵadvance(delta) {\n  ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());\n}\nfunction selectIndexInternal(tView, lView, index, checkNoChangesMode) {\n  ngDevMode && assertIndexInDeclRange(lView, index);\n  // Flush the initial hooks for elements in the view that have been added up to this point.\n  // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n  if (!checkNoChangesMode) {\n    const hooksInitPhaseCompleted = (lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n    if (hooksInitPhaseCompleted) {\n      const preOrderCheckHooks = tView.preOrderCheckHooks;\n      if (preOrderCheckHooks !== null) {\n        executeCheckHooks(lView, preOrderCheckHooks, index);\n      }\n    } else {\n      const preOrderHooks = tView.preOrderHooks;\n      if (preOrderHooks !== null) {\n        executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, index);\n      }\n    }\n  }\n  // We must set the selected index *after* running the hooks, because hooks may have side-effects\n  // that cause other template functions to run, thus updating the selected index, which is global\n  // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n  // will be altered by the time we leave the `ɵɵadvance` instruction.\n  setSelectedIndex(index);\n}\n\n/**\n * Runs the given function in the [context](guide/dependency-injection-context) of the given\n * `Injector`.\n *\n * Within the function's stack frame, [`inject`](api/core/inject) can be used to inject dependencies\n * from the given `Injector`. Note that `inject` is only usable synchronously, and cannot be used in\n * any asynchronous callbacks or after any `await` points.\n *\n * @param injector the injector which will satisfy calls to [`inject`](api/core/inject) while `fn`\n *     is executing\n * @param fn the closure to be run in the context of `injector`\n * @returns the return value of the function, if any\n * @publicApi\n */\nfunction runInInjectionContext(injector, fn) {\n  if (injector instanceof R3Injector) {\n    injector.assertNotDestroyed();\n  }\n  const prevInjector = setCurrentInjector(injector);\n  const previousInjectImplementation = setInjectImplementation(undefined);\n  try {\n    return fn();\n  } finally {\n    setCurrentInjector(prevInjector);\n    setInjectImplementation(previousInjectImplementation);\n  }\n}\n/**\n * Asserts that the current stack frame is within an [injection\n * context](guide/dependency-injection-context) and has access to `inject`.\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n *\n * @publicApi\n */\nfunction assertInInjectionContext(debugFn) {\n  // Taking a `Function` instead of a string name here prevents the unminified name of the function\n  // from being retained in the bundle regardless of minification.\n  if (!getInjectImplementation() && !getCurrentInjector()) {\n    throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode && debugFn.name + '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');\n  }\n}\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreDiEnv = {\n  'ɵɵdefineInjectable': ɵɵdefineInjectable,\n  'ɵɵdefineInjector': ɵɵdefineInjector,\n  'ɵɵinject': ɵɵinject,\n  'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n  'resolveForwardRef': resolveForwardRef\n};\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * injectable def (`ɵprov`) onto the injectable type.\n */\nfunction compileInjectable(type, meta) {\n  let ngInjectableDef = null;\n  let ngFactoryDef = null;\n  // if NG_PROV_DEF is already defined on this class then don't overwrite it\n  if (!type.hasOwnProperty(NG_PROV_DEF)) {\n    Object.defineProperty(type, NG_PROV_DEF, {\n      get: () => {\n        if (ngInjectableDef === null) {\n          const compiler = getCompilerFacade({\n            usage: 0 /* JitCompilerUsage.Decorator */,\n            kind: 'injectable',\n            type\n          });\n          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));\n        }\n        return ngInjectableDef;\n      }\n    });\n  }\n  // if NG_FACTORY_DEF is already defined on this class then don't overwrite it\n  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n    Object.defineProperty(type, NG_FACTORY_DEF, {\n      get: () => {\n        if (ngFactoryDef === null) {\n          const compiler = getCompilerFacade({\n            usage: 0 /* JitCompilerUsage.Decorator */,\n            kind: 'injectable',\n            type\n          });\n          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {\n            name: type.name,\n            type,\n            typeArgumentCount: 0,\n            deps: reflectDependencies(type),\n            target: compiler.FactoryTarget.Injectable\n          });\n        }\n        return ngFactoryDef;\n      },\n      // Leave this configurable so that the factories from directives or pipes can take precedence.\n      configurable: true\n    });\n  }\n}\nconst USE_VALUE = getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\nfunction isUseClassProvider(meta) {\n  return meta.useClass !== undefined;\n}\nfunction isUseValueProvider(meta) {\n  return USE_VALUE in meta;\n}\nfunction isUseFactoryProvider(meta) {\n  return meta.useFactory !== undefined;\n}\nfunction isUseExistingProvider(meta) {\n  return meta.useExisting !== undefined;\n}\nfunction getInjectableMetadata(type, srcMeta) {\n  // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n  const meta = srcMeta || {\n    providedIn: null\n  };\n  const compilerMeta = {\n    name: type.name,\n    type: type,\n    typeArgumentCount: 0,\n    providedIn: meta.providedIn\n  };\n  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n    compilerMeta.deps = convertDependencies(meta.deps);\n  }\n  // Check to see if the user explicitly provided a `useXxxx` property.\n  if (isUseClassProvider(meta)) {\n    compilerMeta.useClass = meta.useClass;\n  } else if (isUseValueProvider(meta)) {\n    compilerMeta.useValue = meta.useValue;\n  } else if (isUseFactoryProvider(meta)) {\n    compilerMeta.useFactory = meta.useFactory;\n  } else if (isUseExistingProvider(meta)) {\n    compilerMeta.useExisting = meta.useExisting;\n  }\n  return compilerMeta;\n}\n\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => compileInjectable(type, meta));\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n  injector.resolveInjectorInitializers();\n  return injector;\n}\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\n  name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see {@link StaticProvider}\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nclass Injector {\n  static create(options, parent) {\n    if (Array.isArray(options)) {\n      return createInjector({\n        name: ''\n      }, parent, options, '');\n    } else {\n      const name = options.name ?? '';\n      return createInjector({\n        name\n      }, options.parent, options.providers, name);\n    }\n  }\n  /** @nocollapse */\n}\n\n/**\n * @module\n * @description\n * The `di` module provides dependency injection container services.\n */\n\n/**\n * This file should not be necessary because node resolution should just default to `./di/index`!\n *\n * However it does not seem to work and it breaks:\n *  - //packages/animations/browser/test:test_web_chromium-local\n *  - //packages/compiler-cli/test:extract_i18n\n *  - //packages/compiler-cli/test:ngc\n *  - //packages/compiler-cli/test:perform_watch\n *  - //packages/compiler-cli/test/diagnostics:check_types\n *  - //packages/compiler-cli/test/transformers:test\n *  - //packages/compiler/test:test\n *  - //tools/public_api_guard:core_api\n *\n * Remove this file once the above is solved or wait until `ngc` is deleted and then it should be\n * safe to delete this file.\n */\nInjector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\nInjector.NULL = /* @__PURE__ */new NullInjector();\nInjector.ɵprov = ɵɵdefineInjectable({\n  token: Injector,\n  providedIn: 'any',\n  factory: () => ɵɵinject(INJECTOR)\n});\n/**\n * @internal\n * @nocollapse\n */\nInjector.__NG_ELEMENT_ID__ = -1 /* InjectorMarkers.Injector */;\n\nfunction ɵɵdirectiveInject(token, flags = InjectFlags.Default) {\n  const lView = getLView();\n  // Fall back to inject() if view hasn't been created. This situation can happen in tests\n  // if inject utilities are used before bootstrapping.\n  if (lView === null) {\n    // Verify that we will not get into infinite loop.\n    ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);\n    return ɵɵinject(token, flags);\n  }\n  const tNode = getCurrentTNode();\n  return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction ɵɵinvalidFactory() {\n  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';\n  throw new Error(msg);\n}\n\n/**\n * Invoke `HostBindingsFunction`s for view.\n *\n * This methods executes `TView.hostBindingOpCodes`. It is used to execute the\n * `HostBindingsFunction`s associated with the current `LView`.\n *\n * @param tView Current `TView`.\n * @param lView Current `LView`.\n */\nfunction processHostBindingOpCodes(tView, lView) {\n  const hostBindingOpCodes = tView.hostBindingOpCodes;\n  if (hostBindingOpCodes === null) return;\n  const consumer = getReactiveLViewConsumer(lView, REACTIVE_HOST_BINDING_CONSUMER);\n  try {\n    for (let i = 0; i < hostBindingOpCodes.length; i++) {\n      const opCode = hostBindingOpCodes[i];\n      if (opCode < 0) {\n        // Negative numbers are element indexes.\n        setSelectedIndex(~opCode);\n      } else {\n        // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n        const directiveIdx = opCode;\n        const bindingRootIndx = hostBindingOpCodes[++i];\n        const hostBindingFn = hostBindingOpCodes[++i];\n        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n        const context = lView[directiveIdx];\n        consumer.runInContext(hostBindingFn, 2 /* RenderFlags.Update */, context);\n      }\n    }\n  } finally {\n    if (lView[REACTIVE_HOST_BINDING_CONSUMER] === null) {\n      commitLViewConsumerIfHasProducers(lView, REACTIVE_HOST_BINDING_CONSUMER);\n    }\n    setSelectedIndex(-1);\n  }\n}\nfunction createLView(parentLView, tView, context, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {\n  const lView = tView.blueprint.slice();\n  lView[HOST] = host;\n  lView[FLAGS] = flags | 4 /* LViewFlags.CreationMode */ | 128 /* LViewFlags.Attached */ | 8 /* LViewFlags.FirstLViewPass */;\n  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */) {\n    lView[FLAGS] |= 2048 /* LViewFlags.HasEmbeddedViewInjector */;\n  }\n\n  resetPreOrderHookFlags(lView);\n  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context;\n  lView[ENVIRONMENT] = environment || parentLView && parentLView[ENVIRONMENT];\n  ngDevMode && assertDefined(lView[ENVIRONMENT], 'LViewEnvironment is required');\n  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];\n  ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n  lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;\n  lView[T_HOST] = tHostNode;\n  lView[ID] = getUniqueLViewId();\n  lView[HYDRATION] = hydrationInfo;\n  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;\n  ngDevMode && assertEqual(tView.type == 2 /* TViewType.Embedded */ ? parentLView !== null : true, true, 'Embedded views must have parentLView');\n  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 /* TViewType.Embedded */ ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;\n  return lView;\n}\nfunction getOrCreateTNode(tView, index, type, name, attrs) {\n  ngDevMode && index !== 0 &&\n  // 0 are bogus nodes and they are OK. See `createContainerRef` in\n  // `view_engine_compatibility` for additional context.\n  assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n  // Keep this function short, so that the VM will inline it.\n  ngDevMode && assertPureTNodeType(type);\n  let tNode = tView.data[index];\n  if (tNode === null) {\n    tNode = createTNodeAtIndex(tView, index, type, name, attrs);\n    if (isInI18nBlock()) {\n      // If we are in i18n block then all elements should be pre declared through `Placeholder`\n      // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n      // If the `TNode` was not pre-declared than it means it was not mentioned which means it was\n      // removed, so we mark it as detached.\n      tNode.flags |= 32 /* TNodeFlags.isDetached */;\n    }\n  } else if (tNode.type & 64 /* TNodeType.Placeholder */) {\n    tNode.type = type;\n    tNode.value = name;\n    tNode.attrs = attrs;\n    const parent = getCurrentParentTNode();\n    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n    ngDevMode && assertTNodeForTView(tNode, tView);\n    ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');\n  }\n  setCurrentTNode(tNode, true);\n  return tNode;\n}\nfunction createTNodeAtIndex(tView, index, type, name, attrs) {\n  const currentTNode = getCurrentTNodePlaceholderOk();\n  const isParent = isCurrentTNodeParent();\n  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;\n  // Parents cannot cross component boundaries because components will be used in multiple places.\n  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);\n  // Assign a pointer to the first child node of a given view. The first node is not always the one\n  // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n  // the index 1 or more, so we can't just check node index.\n  if (tView.firstChild === null) {\n    tView.firstChild = tNode;\n  }\n  if (currentTNode !== null) {\n    if (isParent) {\n      // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?\n      if (currentTNode.child == null && tNode.parent !== null) {\n        // We are in the same view, which means we are adding content node to the parent view.\n        currentTNode.child = tNode;\n      }\n    } else {\n      if (currentTNode.next === null) {\n        // In the case of i18n the `currentTNode` may already be linked, in which case we don't want\n        // to break the links which i18n created.\n        currentTNode.next = tNode;\n        tNode.prev = currentTNode;\n      }\n    }\n  }\n  return tNode;\n}\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply()), we need to adjust the blueprint for future\n * template passes.\n *\n * @param tView `TView` associated with `LView`\n * @param lView The `LView` containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n * @param initialValue Initial value to store in blueprint\n */\nfunction allocExpando(tView, lView, numSlotsToAlloc, initialValue) {\n  if (numSlotsToAlloc === 0) return -1;\n  if (ngDevMode) {\n    assertFirstCreatePass(tView);\n    assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');\n    assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');\n    assertEqual(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');\n    assertFirstUpdatePass(tView);\n  }\n  const allocIdx = lView.length;\n  for (let i = 0; i < numSlotsToAlloc; i++) {\n    lView.push(initialValue);\n    tView.blueprint.push(initialValue);\n    tView.data.push(null);\n  }\n  return allocIdx;\n}\nfunction executeTemplate(tView, lView, templateFn, rf, context) {\n  const consumer = getReactiveLViewConsumer(lView, REACTIVE_TEMPLATE_CONSUMER);\n  const prevSelectedIndex = getSelectedIndex();\n  const isUpdatePhase = rf & 2 /* RenderFlags.Update */;\n  try {\n    setSelectedIndex(-1);\n    if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n      // When we're updating, inherently select 0 so we don't\n      // have to generate that instruction for most update blocks.\n      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());\n    }\n    const preHookType = isUpdatePhase ? 2 /* ProfilerEvent.TemplateUpdateStart */ : 0 /* ProfilerEvent.TemplateCreateStart */;\n    profiler(preHookType, context);\n    if (isUpdatePhase) {\n      consumer.runInContext(templateFn, rf, context);\n    } else {\n      const prevConsumer = setActiveConsumer(null);\n      try {\n        templateFn(rf, context);\n      } finally {\n        setActiveConsumer(prevConsumer);\n      }\n    }\n  } finally {\n    if (isUpdatePhase && lView[REACTIVE_TEMPLATE_CONSUMER] === null) {\n      commitLViewConsumerIfHasProducers(lView, REACTIVE_TEMPLATE_CONSUMER);\n    }\n    setSelectedIndex(prevSelectedIndex);\n    const postHookType = isUpdatePhase ? 3 /* ProfilerEvent.TemplateUpdateEnd */ : 1 /* ProfilerEvent.TemplateCreateEnd */;\n    profiler(postHookType, context);\n  }\n}\n//////////////////////////\n//// Element\n//////////////////////////\nfunction executeContentQueries(tView, tNode, lView) {\n  if (isContentQueryHost(tNode)) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      const start = tNode.directiveStart;\n      const end = tNode.directiveEnd;\n      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n        const def = tView.data[directiveIndex];\n        if (def.contentQueries) {\n          def.contentQueries(1 /* RenderFlags.Create */, lView[directiveIndex], directiveIndex);\n        }\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}\n/**\n * Creates directive instances.\n */\nfunction createDirectivesInstances(tView, lView, tNode) {\n  if (!getBindingsEnabled()) return;\n  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n  if ((tNode.flags & 64 /* TNodeFlags.hasHostBindings */) === 64 /* TNodeFlags.hasHostBindings */) {\n    invokeDirectivesHostBindings(tView, lView, tNode);\n  }\n}\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1];\n      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\nfunction getOrCreateComponentTView(def) {\n  const tView = def.tView;\n  // Create a TView if there isn't one, or recreate it if the first create pass didn't\n  // complete successfully since we can't know for sure whether it's in a usable shape.\n  if (tView === null || tView.incompleteFirstPass) {\n    // Declaration node here is null since this function is called when we dynamically create a\n    // component and hence there is no declaration.\n    const declTNode = null;\n    return def.tView = createTView(1 /* TViewType.Component */, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);\n  }\n  return tView;\n}\n/**\n * Creates a TView instance\n *\n * @param type Type of `TView`.\n * @param declTNode Declaration location of this `TView`.\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\nfunction createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + decls;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;\n  const tView = blueprint[TVIEW] = {\n    type: type,\n    blueprint: blueprint,\n    template: templateFn,\n    queries: null,\n    viewQuery: viewQuery,\n    declTNode: declTNode,\n    data: blueprint.slice().fill(null, bindingStartIndex),\n    bindingStartIndex: bindingStartIndex,\n    expandoStartIndex: initialViewLength,\n    hostBindingOpCodes: null,\n    firstCreatePass: true,\n    firstUpdatePass: true,\n    staticViewQueries: false,\n    staticContentQueries: false,\n    preOrderHooks: null,\n    preOrderCheckHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    cleanup: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === 'function' ? directives() : directives,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    firstChild: null,\n    schemas: schemas,\n    consts: consts,\n    incompleteFirstPass: false,\n    ssrId\n  };\n  if (ngDevMode) {\n    // For performance reasons it is important that the tView retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tView);\n  }\n  return tView;\n}\nfunction createViewBlueprint(bindingStartIndex, initialViewLength) {\n  const blueprint = [];\n  for (let i = 0; i < initialViewLength; i++) {\n    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n  }\n  return blueprint;\n}\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param renderer the renderer used to locate the element.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n * @param injector Root view injector instance.\n */\nfunction locateHostElement(renderer, elementOrSelector, encapsulation, injector) {\n  // Note: we use default value for the `PRESERVE_HOST_CONTENT` here even though it's a\n  // tree-shakable one (providedIn:'root'). This code path can be triggered during dynamic\n  // component creation (after calling ViewContainerRef.createComponent) when an injector\n  // instance can be provided. The injector instance might be disconnected from the main DI\n  // tree, thus the `PRESERVE_HOST_CONTENT` would not be able to instantiate. In this case, the\n  // default value will be used.\n  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);\n  // When using native Shadow DOM, do not clear host element to allow native slot\n  // projection.\n  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation$1.ShadowDom;\n  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);\n  applyRootElementTransform(rootElement);\n  return rootElement;\n}\n/**\n * Applies any root element transformations that are needed. If hydration is enabled,\n * this will process corrupted text nodes.\n *\n * @param rootElement the app root HTML Element\n */\nfunction applyRootElementTransform(rootElement) {\n  _applyRootElementTransformImpl(rootElement);\n}\n/**\n * Reference to a function that applies transformations to the root HTML element\n * of an app. When hydration is enabled, this processes any corrupt text nodes\n * so they are properly hydratable on the client.\n *\n * @param rootElement the app root HTML Element\n */\nlet _applyRootElementTransformImpl = rootElement => null;\n/**\n * Processes text node markers before hydration begins. This replaces any special comment\n * nodes that were added prior to serialization are swapped out to restore proper text\n * nodes before hydration.\n *\n * @param rootElement the app root HTML Element\n */\nfunction applyRootElementTransformImpl(rootElement) {\n  if (hasSkipHydrationAttrOnRElement(rootElement)) {\n    // Handle a situation when the `ngSkipHydration` attribute is applied\n    // to the root node of an application. In this case, we should clear\n    // the contents and render everything from scratch.\n    clearElementContents(rootElement);\n  } else {\n    processTextNodeMarkersBeforeHydration(rootElement);\n  }\n}\n/**\n * Sets the implementation for the `applyRootElementTransform` function.\n */\nfunction enableApplyRootElementTransformImpl() {\n  _applyRootElementTransformImpl = applyRootElementTransformImpl;\n}\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  // Historically the `storeCleanupWithContext` was used to register both framework-level and\n  // user-defined cleanup callbacks, but over time those two types of cleanups were separated.\n  // This dev mode checks assures that user-level cleanup callbacks are _not_ stored in data\n  // structures reserved for framework-specific hooks.\n  ngDevMode && assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');\n  lCleanup.push(context);\n  if (tView.firstCreatePass) {\n    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n  } else {\n    // Make sure that no new framework-level cleanup functions are registered after the first\n    // template pass is done (and TView data structures are meant to fully constructed).\n    if (ngDevMode) {\n      Object.freeze(getOrCreateTViewCleanup(tView));\n    }\n  }\n}\nfunction createTNode(tView, tParent, type, index, value, attrs) {\n  ngDevMode && index !== 0 &&\n  // 0 are bogus nodes and they are OK. See `createContainerRef` in\n  // `view_engine_compatibility` for additional context.\n  assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n  ngDevMode && assertNotSame(attrs, undefined, '\\'undefined\\' is not valid value for \\'attrs\\'');\n  ngDevMode && ngDevMode.tNode++;\n  ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n  let injectorIndex = tParent ? tParent.injectorIndex : -1;\n  let flags = 0;\n  if (isInSkipHydrationBlock$1()) {\n    flags |= 128 /* TNodeFlags.inSkipHydrationBlock */;\n  }\n\n  const tNode = {\n    type,\n    index,\n    insertBeforeIndex: null,\n    injectorIndex,\n    directiveStart: -1,\n    directiveEnd: -1,\n    directiveStylingLast: -1,\n    componentOffset: -1,\n    propertyBindings: null,\n    flags,\n    providerIndexes: 0,\n    value: value,\n    attrs: attrs,\n    mergedAttrs: null,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: null,\n    outputs: null,\n    tView: null,\n    next: null,\n    prev: null,\n    projectionNext: null,\n    child: null,\n    parent: tParent,\n    projection: null,\n    styles: null,\n    stylesWithoutHost: null,\n    residualStyles: undefined,\n    classes: null,\n    classesWithoutHost: null,\n    residualClasses: undefined,\n    classBindings: 0,\n    styleBindings: 0\n  };\n  if (ngDevMode) {\n    // For performance reasons it is important that the tNode retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tNode);\n  }\n  return tNode;\n}\n/**\n * Generates the `PropertyAliases` data structure from the provided input/output mapping.\n * @param aliasMap Input/output mapping from the directive definition.\n * @param directiveIndex Index of the directive.\n * @param propertyAliases Object in which to store the results.\n * @param hostDirectiveAliasMap Object used to alias or filter out properties for host directives.\n * If the mapping is provided, it'll act as an allowlist, as well as a mapping of what public\n * name inputs/outputs should be exposed under.\n */\nfunction generatePropertyAliases(aliasMap, directiveIndex, propertyAliases, hostDirectiveAliasMap) {\n  for (let publicName in aliasMap) {\n    if (aliasMap.hasOwnProperty(publicName)) {\n      propertyAliases = propertyAliases === null ? {} : propertyAliases;\n      const internalName = aliasMap[publicName];\n      // If there are no host directive mappings, we want to remap using the alias map from the\n      // definition itself. If there is an alias map, it has two functions:\n      // 1. It serves as an allowlist of bindings that are exposed by the host directives. Only the\n      // ones inside the host directive map will be exposed on the host.\n      // 2. The public name of the property is aliased using the host directive alias map, rather\n      // than the alias map from the definition.\n      if (hostDirectiveAliasMap === null) {\n        addPropertyAlias(propertyAliases, directiveIndex, publicName, internalName);\n      } else if (hostDirectiveAliasMap.hasOwnProperty(publicName)) {\n        addPropertyAlias(propertyAliases, directiveIndex, hostDirectiveAliasMap[publicName], internalName);\n      }\n    }\n  }\n  return propertyAliases;\n}\nfunction addPropertyAlias(propertyAliases, directiveIndex, publicName, internalName) {\n  if (propertyAliases.hasOwnProperty(publicName)) {\n    propertyAliases[publicName].push(directiveIndex, internalName);\n  } else {\n    propertyAliases[publicName] = [directiveIndex, internalName];\n  }\n}\n/**\n * Initializes data structures required to work with directive inputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\nfunction initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefinitionMap) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const tViewData = tView.data;\n  const tNodeAttrs = tNode.attrs;\n  const inputsFromAttrs = [];\n  let inputsStore = null;\n  let outputsStore = null;\n  for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n    const directiveDef = tViewData[directiveIndex];\n    const aliasData = hostDirectiveDefinitionMap ? hostDirectiveDefinitionMap.get(directiveDef) : null;\n    const aliasedInputs = aliasData ? aliasData.inputs : null;\n    const aliasedOutputs = aliasData ? aliasData.outputs : null;\n    inputsStore = generatePropertyAliases(directiveDef.inputs, directiveIndex, inputsStore, aliasedInputs);\n    outputsStore = generatePropertyAliases(directiveDef.outputs, directiveIndex, outputsStore, aliasedOutputs);\n    // Do not use unbound attributes as inputs to structural directives, since structural\n    // directive inputs can only be set using microsyntax (e.g. `<div *dir=\"exp\">`).\n    // TODO(FW-1930): microsyntax expressions may also contain unbound/static attributes, which\n    // should be set for inline templates.\n    const initialInputs = inputsStore !== null && tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(inputsStore, directiveIndex, tNodeAttrs) : null;\n    inputsFromAttrs.push(initialInputs);\n  }\n  if (inputsStore !== null) {\n    if (inputsStore.hasOwnProperty('class')) {\n      tNode.flags |= 8 /* TNodeFlags.hasClassInput */;\n    }\n\n    if (inputsStore.hasOwnProperty('style')) {\n      tNode.flags |= 16 /* TNodeFlags.hasStyleInput */;\n    }\n  }\n\n  tNode.initialInputs = inputsFromAttrs;\n  tNode.inputs = inputsStore;\n  tNode.outputs = outputsStore;\n}\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\nfunction mapPropName(name) {\n  if (name === 'class') return 'className';\n  if (name === 'for') return 'htmlFor';\n  if (name === 'formaction') return 'formAction';\n  if (name === 'innerHtml') return 'innerHTML';\n  if (name === 'readonly') return 'readOnly';\n  if (name === 'tabindex') return 'tabIndex';\n  return name;\n}\nfunction elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  const element = getNativeByTNode(tNode, lView);\n  let inputData = tNode.inputs;\n  let dataValue;\n  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n    setInputsForProperty(tView, lView, dataValue, propName, value);\n    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);\n    if (ngDevMode) {\n      setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n    }\n  } else if (tNode.type & 3 /* TNodeType.AnyRNode */) {\n    propName = mapPropName(propName);\n    if (ngDevMode) {\n      validateAgainstEventProperties(propName);\n      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {\n        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n      }\n      ngDevMode.rendererSetProperty++;\n    }\n    // It is assumed that the sanitizer is only added when the compiler determines that the\n    // property is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;\n    renderer.setProperty(element, propName, value);\n  } else if (tNode.type & 12 /* TNodeType.AnyContainer */) {\n    // If the node is a container and the property didn't\n    // match any of the inputs or schemas we should throw.\n    if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {\n      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n    }\n  }\n}\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView, viewIndex) {\n  ngDevMode && assertLView(lView);\n  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & 16 /* LViewFlags.CheckAlways */)) {\n    childComponentLView[FLAGS] |= 64 /* LViewFlags.Dirty */;\n  }\n}\n\nfunction setNgReflectProperty(lView, element, type, attrName, value) {\n  const renderer = lView[RENDERER];\n  attrName = normalizeDebugBindingName(attrName);\n  const debugValue = normalizeDebugBindingValue(value);\n  if (type & 3 /* TNodeType.AnyRNode */) {\n    if (value == null) {\n      renderer.removeAttribute(element, attrName);\n    } else {\n      renderer.setAttribute(element, attrName, debugValue);\n    }\n  } else {\n    const textContent = escapeCommentText(`bindings=${JSON.stringify({\n      [attrName]: debugValue\n    }, null, 2)}`);\n    renderer.setValue(element, textContent);\n  }\n}\nfunction setNgReflectProperties(lView, element, type, dataValue, value) {\n  if (type & (3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */)) {\n    /**\n     * dataValue is an array containing runtime input or output names for the directives:\n     * i+0: directive instance index\n     * i+1: privateName\n     *\n     * e.g. [0, 'change', 'change-minified']\n     * we want to set the reflected property with the privateName: dataValue[i+1]\n     */\n    for (let i = 0; i < dataValue.length; i += 2) {\n      setNgReflectProperty(lView, element, type, dataValue[i + 1], value);\n    }\n  }\n}\n/**\n * Resolve the matched directives on a node.\n */\nfunction resolveDirectives(tView, lView, tNode, localRefs) {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n  // tsickle.\n  ngDevMode && assertFirstCreatePass(tView);\n  if (getBindingsEnabled()) {\n    const exportsMap = localRefs === null ? null : {\n      '': -1\n    };\n    const matchResult = findDirectiveDefMatches(tView, tNode);\n    let directiveDefs;\n    let hostDirectiveDefs;\n    if (matchResult === null) {\n      directiveDefs = hostDirectiveDefs = null;\n    } else {\n      [directiveDefs, hostDirectiveDefs] = matchResult;\n    }\n    if (directiveDefs !== null) {\n      initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs);\n    }\n    if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  }\n  // Merge the template attrs last so that they have the highest priority.\n  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n}\n/** Initializes the data structures necessary for a list of directives to be instantiated. */\nfunction initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs) {\n  ngDevMode && assertFirstCreatePass(tView);\n  // Publishes the directive types to DI so they can be injected. Needs to\n  // happen in a separate pass before the TNode flags have been initialized.\n  for (let i = 0; i < directives.length; i++) {\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, directives[i].type);\n  }\n  initTNodeFlags(tNode, tView.data.length, directives.length);\n  // When the same token is provided by several directives on the same node, some rules apply in\n  // the viewEngine:\n  // - viewProviders have priority over providers\n  // - the last directive in NgModule.declarations has priority over the previous one\n  // So to match these rules, the order in which providers are added in the arrays is very\n  // important.\n  for (let i = 0; i < directives.length; i++) {\n    const def = directives[i];\n    if (def.providersResolver) def.providersResolver(def);\n  }\n  let preOrderHooksFound = false;\n  let preOrderCheckHooksFound = false;\n  let directiveIdx = allocExpando(tView, lView, directives.length, null);\n  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, 'TNode.directiveStart should point to just allocated space');\n  for (let i = 0; i < directives.length; i++) {\n    const def = directives[i];\n    // Merge the attrs in the order of matches. This assumes that the first directive is the\n    // component itself, so that the component has the least priority.\n    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);\n    saveNameToExportMap(directiveIdx, def, exportsMap);\n    if (def.contentQueries !== null) tNode.flags |= 4 /* TNodeFlags.hasContentQuery */;\n    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 64 /* TNodeFlags.hasHostBindings */;\n    const lifeCycleHooks = def.type.prototype;\n    // Only push a node index into the preOrderHooks array if this is the first\n    // pre-order hook found on this node.\n    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {\n      // We will push the actual hook function into this array later during dir instantiation.\n      // We cannot do it now because we must ensure hooks are registered in the same\n      // order that directives are created (i.e. injection order).\n      (tView.preOrderHooks ??= []).push(tNode.index);\n      preOrderHooksFound = true;\n    }\n    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {\n      (tView.preOrderCheckHooks ??= []).push(tNode.index);\n      preOrderCheckHooksFound = true;\n    }\n    directiveIdx++;\n  }\n  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);\n}\n/**\n * Add `hostBindings` to the `TView.hostBindingOpCodes`.\n *\n * @param tView `TView` to which the `hostBindings` should be added.\n * @param tNode `TNode` the element which contains the directive\n * @param directiveIdx Directive index in view.\n * @param directiveVarsIdx Where will the directive's vars be stored\n * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.\n */\nfunction registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const hostBindings = def.hostBindings;\n  if (hostBindings) {\n    let hostBindingOpCodes = tView.hostBindingOpCodes;\n    if (hostBindingOpCodes === null) {\n      hostBindingOpCodes = tView.hostBindingOpCodes = [];\n    }\n    const elementIndx = ~tNode.index;\n    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {\n      // Conditionally add select element so that we are more efficient in execution.\n      // NOTE: this is strictly not necessary and it trades code size for runtime perf.\n      // (We could just always add it.)\n      hostBindingOpCodes.push(elementIndx);\n    }\n    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);\n  }\n}\n/**\n * Returns the last selected element index in the `HostBindingOpCodes`\n *\n * For perf reasons we don't need to update the selected element index in `HostBindingOpCodes` only\n * if it changes. This method returns the last index (or '0' if not found.)\n *\n * Selected element index are only the ones which are negative.\n */\nfunction lastSelectedElementIdx(hostBindingOpCodes) {\n  let i = hostBindingOpCodes.length;\n  while (i > 0) {\n    const value = hostBindingOpCodes[--i];\n    if (typeof value === 'number' && value < 0) {\n      return value;\n    }\n  }\n  return 0;\n}\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(tView, lView, tNode, native) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  // The component view needs to be created before creating the node injector\n  // since it is used to inject some special symbols like `ChangeDetectorRef`.\n  if (isComponentHost(tNode)) {\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */);\n    addComponentLogic(lView, tNode, tView.data[start + tNode.componentOffset]);\n  }\n  if (!tView.firstCreatePass) {\n    getOrCreateNodeInjectorForNode(tNode, lView);\n  }\n  attachPatchData(native, lView);\n  const initialInputs = tNode.initialInputs;\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i];\n    const directive = getNodeInjectable(lView, tView, i, tNode);\n    attachPatchData(directive, lView);\n    if (initialInputs !== null) {\n      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);\n    }\n    if (isComponentDef(def)) {\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);\n    }\n  }\n}\nfunction invokeDirectivesHostBindings(tView, lView, tNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const elementIndex = tNode.index;\n  const currentDirectiveIndex = getCurrentDirectiveIndex();\n  try {\n    setSelectedIndex(elementIndex);\n    for (let dirIndex = start; dirIndex < end; dirIndex++) {\n      const def = tView.data[dirIndex];\n      const directive = lView[dirIndex];\n      setCurrentDirectiveIndex(dirIndex);\n      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n        invokeHostBindingsInCreationMode(def, directive);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n  }\n}\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\nfunction invokeHostBindingsInCreationMode(def, directive) {\n  if (def.hostBindings !== null) {\n    def.hostBindings(1 /* RenderFlags.Create */, directive);\n  }\n}\n/**\n * Matches the current node against all available selectors.\n * If a component is matched (at most one), it is returned in first position in the array.\n */\nfunction findDirectiveDefMatches(tView, tNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n  const registry = tView.directiveRegistry;\n  let matches = null;\n  let hostDirectiveDefs = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i];\n      if (isNodeMatchingSelectorList(tNode, def.selectors, /* isProjectionMode */false)) {\n        matches || (matches = []);\n        if (isComponentDef(def)) {\n          if (ngDevMode) {\n            assertTNodeType(tNode, 2 /* TNodeType.Element */, `\"${tNode.value}\" tags cannot be used as component hosts. ` + `Please use a different tag to activate the ${stringify(def.type)} component.`);\n            if (isComponentHost(tNode)) {\n              throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);\n            }\n          }\n          // Components are inserted at the front of the matches array so that their lifecycle\n          // hooks run before any directive lifecycle hooks. This appears to be for ViewEngine\n          // compatibility. This logic doesn't make sense with host directives, because it\n          // would allow the host directives to undo any overrides the host may have made.\n          // To handle this case, the host directives of components are inserted at the beginning\n          // of the array, followed by the component. As such, the insertion order is as follows:\n          // 1. Host directives belonging to the selector-matched component.\n          // 2. Selector-matched component.\n          // 3. Host directives belonging to selector-matched directives.\n          // 4. Selector-matched directives.\n          if (def.findHostDirectiveDefs !== null) {\n            const hostDirectiveMatches = [];\n            hostDirectiveDefs = hostDirectiveDefs || new Map();\n            def.findHostDirectiveDefs(def, hostDirectiveMatches, hostDirectiveDefs);\n            // Add all host directives declared on this component, followed by the component itself.\n            // Host directives should execute first so the host has a chance to override changes\n            // to the DOM made by them.\n            matches.unshift(...hostDirectiveMatches, def);\n            // Component is offset starting from the beginning of the host directives array.\n            const componentOffset = hostDirectiveMatches.length;\n            markAsComponentHost(tView, tNode, componentOffset);\n          } else {\n            // No host directives on this component, just add the\n            // component def to the beginning of the matches.\n            matches.unshift(def);\n            markAsComponentHost(tView, tNode, 0);\n          }\n        } else {\n          // Append any host directives to the matches first.\n          hostDirectiveDefs = hostDirectiveDefs || new Map();\n          def.findHostDirectiveDefs?.(def, matches, hostDirectiveDefs);\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches === null ? null : [matches, hostDirectiveDefs];\n}\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting the component offset on the TNode.\n * - storing index of component's host element so it will be queued for view refresh during CD.\n */\nfunction markAsComponentHost(tView, hostTNode, componentOffset) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertGreaterThan(componentOffset, -1, 'componentOffset must be great than -1');\n  hostTNode.componentOffset = componentOffset;\n  (tView.components ??= []).push(hostTNode.index);\n}\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(tNode, localRefs, exportsMap) {\n  if (localRefs) {\n    const localNames = tNode.localNames = [];\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new RuntimeError(-301 /* RuntimeErrorCode.EXPORT_NOT_FOUND */, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(directiveIdx, def, exportsMap) {\n  if (exportsMap) {\n    if (def.exportAs) {\n      for (let i = 0; i < def.exportAs.length; i++) {\n        exportsMap[def.exportAs[i]] = directiveIdx;\n      }\n    }\n    if (isComponentDef(def)) exportsMap[''] = directiveIdx;\n  }\n}\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nfunction initTNodeFlags(tNode, index, numberOfDirectives) {\n  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');\n  tNode.flags |= 1 /* TNodeFlags.isDirectiveHost */;\n  // When the first directive is created on a node, save the index\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n/**\n * Setup directive for instantiation.\n *\n * We need to create a `NodeInjectorFactory` which is then inserted in both the `Blueprint` as well\n * as `LView`. `TView` gets the `DirectiveDef`.\n *\n * @param tView `TView`\n * @param tNode `TNode`\n * @param lView `LView`\n * @param directiveIndex Index where the directive will be stored in the Expando.\n * @param def `DirectiveDef`\n */\nfunction configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {\n  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');\n  tView.data[directiveIndex] = def;\n  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));\n  // Even though `directiveFactory` will already be using `ɵɵdirectiveInject` in its generated code,\n  // we also want to support `inject()` directly from the directive constructor context so we set\n  // `ɵɵdirectiveInject` as the inject implementation here too.\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), ɵɵdirectiveInject);\n  tView.blueprint[directiveIndex] = nodeInjectorFactory;\n  lView[directiveIndex] = nodeInjectorFactory;\n  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);\n}\nfunction addComponentLogic(lView, hostTNode, def) {\n  const native = getNativeByTNode(hostTNode, lView);\n  const tView = getOrCreateComponentTView(def);\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const rendererFactory = lView[ENVIRONMENT].rendererFactory;\n  let lViewFlags = 16 /* LViewFlags.CheckAlways */;\n  if (def.signals) {\n    lViewFlags = 4096 /* LViewFlags.SignalView */;\n  } else if (def.onPush) {\n    lViewFlags = 64 /* LViewFlags.Dirty */;\n  }\n\n  const componentView = addToViewTree(lView, createLView(lView, tView, null, lViewFlags, native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  lView[hostTNode.index] = componentView;\n}\nfunction elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {\n  if (ngDevMode) {\n    assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n    validateAgainstEventAttributes(name);\n    assertTNodeType(tNode, 2 /* TNodeType.Element */, `Attempted to set attribute \\`${name}\\` on a container node. ` + `Host bindings are not valid on ng-container or ng-template.`);\n  }\n  const element = getNativeByTNode(tNode, lView);\n  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\nfunction setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {\n  if (value == null) {\n    ngDevMode && ngDevMode.rendererRemoveAttribute++;\n    renderer.removeAttribute(element, name, namespace);\n  } else {\n    ngDevMode && ngDevMode.rendererSetAttribute++;\n    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n    renderer.setAttribute(element, name, strValue, namespace);\n  }\n}\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {\n  const initialInputs = initialInputData[directiveIndex];\n  if (initialInputs !== null) {\n    for (let i = 0; i < initialInputs.length;) {\n      const publicName = initialInputs[i++];\n      const privateName = initialInputs[i++];\n      const value = initialInputs[i++];\n      writeToDirectiveInput(def, instance, publicName, privateName, value);\n      if (ngDevMode) {\n        const nativeElement = getNativeByTNode(tNode, lView);\n        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n      }\n    }\n  }\n}\nfunction writeToDirectiveInput(def, instance, publicName, privateName, value) {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    const inputTransforms = def.inputTransforms;\n    if (inputTransforms !== null && inputTransforms.hasOwnProperty(privateName)) {\n      value = inputTransforms[privateName].call(instance, value);\n    }\n    if (def.setInput !== null) {\n      def.setInput(instance, value, publicName, privateName);\n    } else {\n      instance[privateName] = value;\n    }\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs Input alias map that was generated from the directive def inputs.\n * @param directiveIndex Index of the directive that is currently being processed.\n * @param attrs Static attrs on this node.\n */\nfunction generateInitialInputs(inputs, directiveIndex, attrs) {\n  let inputsToStore = null;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === 0 /* AttributeMarker.NamespaceURI */) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    } else if (attrName === 5 /* AttributeMarker.ProjectAs */) {\n      // Skip over the `ngProjectAs` value.\n      i += 2;\n      continue;\n    }\n    // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n    if (typeof attrName === 'number') break;\n    if (inputs.hasOwnProperty(attrName)) {\n      if (inputsToStore === null) inputsToStore = [];\n      // Find the input's public name from the input store. Note that we can be found easier\n      // through the directive def, but we want to do it using the inputs store so that it can\n      // account for host directive aliases.\n      const inputConfig = inputs[attrName];\n      for (let j = 0; j < inputConfig.length; j += 2) {\n        if (inputConfig[j] === directiveIndex) {\n          inputsToStore.push(attrName, inputConfig[j + 1], attrs[i + 1]);\n          // A directive can't have multiple inputs with the same name so we can break here.\n          break;\n        }\n      }\n    }\n    i += 2;\n  }\n  return inputsToStore;\n}\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nfunction createLContainer(hostNative, currentView, native, tNode) {\n  ngDevMode && assertLView(currentView);\n  const lContainer = [hostNative, true, false, currentView, null, 0, tNode, native, null, null, null // dehydrated views\n  ];\n\n  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, 'Should allocate correct number of slots for LContainer header.');\n  return lContainer;\n}\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView, lView) {\n  const contentQueries = tView.contentQueries;\n  if (contentQueries !== null) {\n    for (let i = 0; i < contentQueries.length; i += 2) {\n      const queryStartIdx = contentQueries[i];\n      const directiveDefIdx = contentQueries[i + 1];\n      if (directiveDefIdx !== -1) {\n        const directiveDef = tView.data[directiveDefIdx];\n        ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');\n        ngDevMode && assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n        setCurrentQueryIndex(queryStartIdx);\n        directiveDef.contentQueries(2 /* RenderFlags.Update */, lView[directiveDefIdx], directiveDefIdx);\n      }\n    }\n  }\n}\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nfunction addToViewTree(lView, lViewOrLContainer) {\n  // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n  // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n  // of order, the change detection will run out of order, as the act of retrieving the the\n  // LContainer from the RNode is what adds it to the queue.\n  if (lView[CHILD_HEAD]) {\n    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;\n  } else {\n    lView[CHILD_HEAD] = lViewOrLContainer;\n  }\n  lView[CHILD_TAIL] = lViewOrLContainer;\n  return lViewOrLContainer;\n}\n///////////////////////////////\n//// Change detection\n///////////////////////////////\nfunction executeViewQueryFn(flags, viewQueryFn, component) {\n  ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n  setCurrentQueryIndex(0);\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    viewQueryFn(flags, component);\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyName�prefix�interpolation_static_part1�..interpolation_static_partN�suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param tNode `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nfunction storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {\n  // Binding meta-data are stored only the first time a given property instruction is processed.\n  // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n  // binding meta-data to decide if one should be stored (or if was stored already).\n  if (tData[bindingIndex] === null) {\n    if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n      propBindingIdxs.push(bindingIndex);\n      let bindingMetadata = propertyName;\n      if (interpolationParts.length > 0) {\n        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n      }\n      tData[bindingIndex] = bindingMetadata;\n    }\n  }\n}\nfunction getOrCreateLViewCleanup(view) {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = []);\n}\nfunction getOrCreateTViewCleanup(tView) {\n  return tView.cleanup || (tView.cleanup = []);\n}\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nfunction loadComponentRenderer(currentDef, tNode, lView) {\n  // TODO(FW-2043): the `currentDef` is null when host bindings are invoked while creating root\n  // component (see packages/core/src/render3/component.ts). This is not consistent with the process\n  // of creating inner components, when current directive index is available in the state. In order\n  // to avoid relying on current def being `null` (thus special-casing root component creation), the\n  // process of creating root component should be unified with the process of creating inner\n  // components.\n  if (currentDef === null || isComponentDef(currentDef)) {\n    lView = unwrapLView(lView[tNode.index]);\n  }\n  return lView[RENDERER];\n}\n/** Handles an error thrown in an LView. */\nfunction handleError(lView, error) {\n  const injector = lView[INJECTOR$1];\n  const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n  errorHandler && errorHandler.handleError(error);\n}\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param tView The current TView\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n *        possibly minified, property names to write to.\n * @param value Value to set.\n */\nfunction setInputsForProperty(tView, lView, inputs, publicName, value) {\n  for (let i = 0; i < inputs.length;) {\n    const index = inputs[i++];\n    const privateName = inputs[i++];\n    const instance = lView[index];\n    ngDevMode && assertIndexInRange(lView, index);\n    const def = tView.data[index];\n    writeToDirectiveInput(def, instance, publicName, privateName, value);\n  }\n}\n/**\n * Updates a text binding at a given index in a given LView.\n */\nfunction textBindingInternal(lView, index, value) {\n  ngDevMode && assertString(value, 'Value should be a string');\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'value should not be NO_CHANGE');\n  ngDevMode && assertIndexInRange(lView, index);\n  const element = getNativeByIndex(index, lView);\n  ngDevMode && assertDefined(element, 'native element should exist');\n  updateTextNode(lView[RENDERER], element, value);\n}\nfunction renderComponent(hostLView, componentHostIdx) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  const componentTView = componentView[TVIEW];\n  syncViewWithBlueprint(componentTView, componentView);\n  const hostRNode = componentView[HOST];\n  // Populate an LView with hydration info retrieved from the DOM via TransferState.\n  if (hostRNode !== null && componentView[HYDRATION] === null) {\n    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR$1]);\n  }\n  renderView(componentTView, componentView, componentView[CONTEXT]);\n}\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\nfunction syncViewWithBlueprint(tView, lView) {\n  for (let i = lView.length; i < tView.blueprint.length; i++) {\n    lView.push(tView.blueprint[i]);\n  }\n}\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nfunction renderView(tView, lView, context) {\n  ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n  enterView(lView);\n  try {\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(1 /* RenderFlags.Create */, viewQuery, context);\n    }\n    // Execute a template associated with this view, if it exists. A template function might not be\n    // defined for the root component views.\n    const templateFn = tView.template;\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, 1 /* RenderFlags.Create */, context);\n    }\n    // This needs to be set before children are processed to support recursive components.\n    // This must be set to false immediately after the first creation run because in an\n    // ngFor loop, all the views will be created together before update mode runs and turns\n    // off firstCreatePass. If we don't set it here, instances will perform directive\n    // matching, etc again and again.\n    if (tView.firstCreatePass) {\n      tView.firstCreatePass = false;\n    }\n    // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n    // content queries are resolved during change detection (i.e. update mode), after embedded\n    // views are refreshed (see block above).\n    if (tView.staticContentQueries) {\n      refreshContentQueries(tView, lView);\n    }\n    // We must materialize query results before child components are processed\n    // in case a child component has projected a container. The LContainer needs\n    // to exist so the embedded views are properly attached by the container.\n    if (tView.staticViewQueries) {\n      executeViewQueryFn(2 /* RenderFlags.Update */, tView.viewQuery, context);\n    }\n    // Render child component views.\n    const components = tView.components;\n    if (components !== null) {\n      renderChildComponents(lView, components);\n    }\n  } catch (error) {\n    // If we didn't manage to get past the first template pass due to\n    // an error, mark the view as corrupted so we can try to recover.\n    if (tView.firstCreatePass) {\n      tView.incompleteFirstPass = true;\n      tView.firstCreatePass = false;\n    }\n    throw error;\n  } finally {\n    lView[FLAGS] &= ~4 /* LViewFlags.CreationMode */;\n    leaveView();\n  }\n}\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView, components) {\n  for (let i = 0; i < components.length; i++) {\n    renderComponent(hostLView, components[i]);\n  }\n}\n\n/**\n * `DestroyRef` lets you set callbacks to run for any cleanup or destruction behavior.\n * The scope of this destruction depends on where `DestroyRef` is injected. If `DestroyRef`\n * is injected in a component or directive, the callbacks run when that component or\n * directive is destroyed. Otherwise the callbacks run when a corresponding injector is destroyed.\n *\n * @publicApi\n */\nclass DestroyRef {}\n/**\n * @internal\n * @nocollapse\n */\nDestroyRef.__NG_ELEMENT_ID__ = injectDestroyRef;\n/**\n * @internal\n * @nocollapse\n */\nDestroyRef.__NG_ENV_ID__ = injector => injector;\nclass NodeInjectorDestroyRef extends DestroyRef {\n  constructor(_lView) {\n    super();\n    this._lView = _lView;\n  }\n  onDestroy(callback) {\n    storeLViewOnDestroy(this._lView, callback);\n    return () => removeLViewOnDestroy(this._lView, callback);\n  }\n}\nfunction injectDestroyRef() {\n  return new NodeInjectorDestroyRef(getLView());\n}\n\n/**\n * Tracks all effects registered within a given application and runs them via `flush`.\n */\nclass EffectManager {\n  constructor() {\n    this.all = new Set();\n    this.queue = new Map();\n  }\n  create(effectFn, destroyRef, allowSignalWrites) {\n    const zone = typeof Zone === 'undefined' ? null : Zone.current;\n    const watch = new Watch(effectFn, watch => {\n      if (!this.all.has(watch)) {\n        return;\n      }\n      this.queue.set(watch, zone);\n    }, allowSignalWrites);\n    this.all.add(watch);\n    // Effects start dirty.\n    watch.notify();\n    let unregisterOnDestroy;\n    const destroy = () => {\n      watch.cleanup();\n      unregisterOnDestroy?.();\n      this.all.delete(watch);\n      this.queue.delete(watch);\n    };\n    unregisterOnDestroy = destroyRef?.onDestroy(destroy);\n    return {\n      destroy\n    };\n  }\n  flush() {\n    if (this.queue.size === 0) {\n      return;\n    }\n    for (const [watch, zone] of this.queue) {\n      this.queue.delete(watch);\n      if (zone) {\n        zone.run(() => watch.run());\n      } else {\n        watch.run();\n      }\n    }\n  }\n  get isQueueEmpty() {\n    return this.queue.size === 0;\n  }\n  /** @nocollapse */\n}\n/**\n * Create a global `Effect` for the given reactive function.\n *\n * @developerPreview\n */\nEffectManager.ɵprov = ɵɵdefineInjectable({\n  token: EffectManager,\n  providedIn: 'root',\n  factory: () => new EffectManager()\n});\nfunction effect(effectFn, options) {\n  !options?.injector && assertInInjectionContext(effect);\n  const injector = options?.injector ?? inject(Injector);\n  const effectManager = injector.get(EffectManager);\n  const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n  return effectManager.create(effectFn, destroyRef, !!options?.allowSignalWrites);\n}\n\n/**\n * Compute the static styling (class/style) from `TAttributes`.\n *\n * This function should be called during `firstCreatePass` only.\n *\n * @param tNode The `TNode` into which the styling information should be loaded.\n * @param attrs `TAttributes` containing the styling information.\n * @param writeToHost Where should the resulting static styles be written?\n *   - `false` Write to `TNode.stylesWithoutHost` / `TNode.classesWithoutHost`\n *   - `true` Write to `TNode.styles` / `TNode.classes`\n */\nfunction computeStaticStyling(tNode, attrs, writeToHost) {\n  ngDevMode && assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');\n  let styles = writeToHost ? tNode.styles : null;\n  let classes = writeToHost ? tNode.classes : null;\n  let mode = 0;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const value = attrs[i];\n      if (typeof value === 'number') {\n        mode = value;\n      } else if (mode == 1 /* AttributeMarker.Classes */) {\n        classes = concatStringsWithSpace(classes, value);\n      } else if (mode == 2 /* AttributeMarker.Styles */) {\n        const style = value;\n        const styleValue = attrs[++i];\n        styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');\n      }\n    }\n  }\n  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;\n  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;\n}\nfunction collectNativeNodes(tView, lView, tNode, result, isProjection = false) {\n  while (tNode !== null) {\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n    const lNode = lView[tNode.index];\n    if (lNode !== null) {\n      result.push(unwrapRNode(lNode));\n    }\n    // A given lNode can represent either a native node or a LContainer (when it is a host of a\n    // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes\n    // from the views in this container.\n    if (isLContainer(lNode)) {\n      for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {\n        const lViewInAContainer = lNode[i];\n        const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n        if (lViewFirstChildTNode !== null) {\n          collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);\n        }\n      }\n      // When an LContainer is created, the anchor (comment) node is:\n      // - (1) either reused in case of an ElementContainer (<ng-container>)\n      // - (2) or a new comment node is created\n      // In the first case, the anchor comment node would be added to the final\n      // list by the code above (`result.push(unwrapRNode(lNode))`), but the second\n      // case requires extra handling: the anchor node needs to be added to the\n      // final list manually. See additional information in the `createAnchorNode`\n      // function in the `view_container_ref.ts`.\n      //\n      // In the first case, the same reference would be stored in the `NATIVE`\n      // and `HOST` slots in an LContainer. Otherwise, this is the second case and\n      // we should add an element to the final list.\n      if (lNode[NATIVE] !== lNode[HOST]) {\n        result.push(lNode[NATIVE]);\n      }\n    }\n    const tNodeType = tNode.type;\n    if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n      collectNativeNodes(tView, lView, tNode.child, result);\n    } else if (tNodeType & 32 /* TNodeType.Icu */) {\n      const nextRNode = icuContainerIterate(tNode, lView);\n      let rNode;\n      while (rNode = nextRNode()) {\n        result.push(rNode);\n      }\n    } else if (tNodeType & 16 /* TNodeType.Projection */) {\n      const nodesInSlot = getProjectionNodes(lView, tNode);\n      if (Array.isArray(nodesInSlot)) {\n        result.push(...nodesInSlot);\n      } else {\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n  return result;\n}\nfunction detectChangesInternal(tView, lView, context, notifyErrorHandler = true) {\n  const rendererFactory = lView[ENVIRONMENT].rendererFactory;\n  // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to invoke renderer factory functions in that mode\n  // to avoid any possible side-effects.\n  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();\n  if (!checkNoChangesMode && rendererFactory.begin) rendererFactory.begin();\n  try {\n    refreshView(tView, lView, tView.template, context);\n  } catch (error) {\n    if (notifyErrorHandler) {\n      handleError(lView, error);\n    }\n    throw error;\n  } finally {\n    if (!checkNoChangesMode && rendererFactory.end) rendererFactory.end();\n    // One final flush of the effects queue to catch any effects created in `ngAfterViewInit` or\n    // other post-order hooks.\n    !checkNoChangesMode && lView[ENVIRONMENT].effectManager?.flush();\n  }\n}\nfunction checkNoChangesInternal(tView, lView, context, notifyErrorHandler = true) {\n  setIsInCheckNoChangesMode(true);\n  try {\n    detectChangesInternal(tView, lView, context, notifyErrorHandler);\n  } finally {\n    setIsInCheckNoChangesMode(false);\n  }\n}\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component.\n *\n * @param component The component which the change detection should be performed on.\n */\nfunction detectChanges(component) {\n  const view = getComponentViewByInstance(component);\n  detectChangesInternal(view[TVIEW], view, component);\n}\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\nfunction refreshView(tView, lView, templateFn, context) {\n  ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n  const flags = lView[FLAGS];\n  if ((flags & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */) return;\n  // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to execute lifecycle hooks in that mode.\n  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n  !isInCheckNoChangesPass && lView[ENVIRONMENT].effectManager?.flush();\n  enterView(lView);\n  try {\n    resetPreOrderHookFlags(lView);\n    setBindingIndex(tView.bindingStartIndex);\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, 2 /* RenderFlags.Update */, context);\n    }\n    const hooksInitPhaseCompleted = (flags & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n    // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const preOrderCheckHooks = tView.preOrderCheckHooks;\n        if (preOrderCheckHooks !== null) {\n          executeCheckHooks(lView, preOrderCheckHooks, null);\n        }\n      } else {\n        const preOrderHooks = tView.preOrderHooks;\n        if (preOrderHooks !== null) {\n          executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, null);\n        }\n        incrementInitPhaseFlags(lView, 0 /* InitPhaseState.OnInitHooksToBeRun */);\n      }\n    }\n    // First mark transplanted views that are declared in this lView as needing a refresh at their\n    // insertion points. This is needed to avoid the situation where the template is defined in this\n    // `LView` but its declaration appears after the insertion component.\n    markTransplantedViewsForRefresh(lView);\n    detectChangesInEmbeddedViews(lView, 2 /* ChangeDetectionMode.BugToForceRefreshAndIgnoreViewFlags */);\n    // Content query results must be refreshed before content hooks are called.\n    if (tView.contentQueries !== null) {\n      refreshContentQueries(tView, lView);\n    }\n    // execute content hooks (AfterContentInit, AfterContentChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const contentCheckHooks = tView.contentCheckHooks;\n        if (contentCheckHooks !== null) {\n          executeCheckHooks(lView, contentCheckHooks);\n        }\n      } else {\n        const contentHooks = tView.contentHooks;\n        if (contentHooks !== null) {\n          executeInitAndCheckHooks(lView, contentHooks, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n        }\n\n        incrementInitPhaseFlags(lView, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n      }\n    }\n\n    processHostBindingOpCodes(tView, lView);\n    // Refresh child component views.\n    const components = tView.components;\n    if (components !== null) {\n      detectChangesInChildComponents(lView, components, 0 /* ChangeDetectionMode.Global */);\n    }\n    // View queries must execute after refreshing child components because a template in this view\n    // could be inserted in a child component. If the view query executes before child component\n    // refresh, the template might not yet be inserted.\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(2 /* RenderFlags.Update */, viewQuery, context);\n    }\n    // execute view hooks (AfterViewInit, AfterViewChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const viewCheckHooks = tView.viewCheckHooks;\n        if (viewCheckHooks !== null) {\n          executeCheckHooks(lView, viewCheckHooks);\n        }\n      } else {\n        const viewHooks = tView.viewHooks;\n        if (viewHooks !== null) {\n          executeInitAndCheckHooks(lView, viewHooks, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n        }\n\n        incrementInitPhaseFlags(lView, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n      }\n    }\n\n    if (tView.firstUpdatePass === true) {\n      // We need to make sure that we only flip the flag on successful `refreshView` only\n      // Don't do this in `finally` block.\n      // If we did this in `finally` block then an exception could block the execution of styling\n      // instructions which in turn would be unable to insert themselves into the styling linked\n      // list. The result of this would be that if the exception would not be throw on subsequent CD\n      // the styling would be unable to process it data and reflect to the DOM.\n      tView.firstUpdatePass = false;\n    }\n    // Do not reset the dirty state when running in check no changes mode. We don't want components\n    // to behave differently depending on whether check no changes is enabled or not. For example:\n    // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n    // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n    // no changes cycle, the component would be not be dirty for the next update pass. This would\n    // be different in production mode where the component dirty state is not reset.\n    if (!isInCheckNoChangesPass) {\n      lView[FLAGS] &= ~(64 /* LViewFlags.Dirty */ | 8 /* LViewFlags.FirstLViewPass */);\n    }\n\n    clearViewRefreshFlag(lView);\n  } finally {\n    leaveView();\n  }\n}\n/**\n * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction detectChangesInEmbeddedViews(lView, mode) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n      detectChangesInView(embeddedLView, mode);\n    }\n  }\n}\n/**\n * Mark transplanted views as needing to be refreshed at their insertion points.\n *\n * @param lView The `LView` that may have transplanted views.\n */\nfunction markTransplantedViewsForRefresh(lView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n    if (!lContainer[HAS_TRANSPLANTED_VIEWS]) continue;\n    const movedViews = lContainer[MOVED_VIEWS];\n    ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n    for (let i = 0; i < movedViews.length; i++) {\n      const movedLView = movedViews[i];\n      const insertionLContainer = movedLView[PARENT];\n      ngDevMode && assertLContainer(insertionLContainer);\n      markViewForRefresh(movedLView);\n    }\n  }\n}\n/**\n * Detects changes in a component by entering the component view and processing its bindings,\n * queries, etc. if it is CheckAlways, OnPush and Dirty, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction detectChangesInComponent(hostLView, componentHostIdx, mode) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  detectChangesInView(componentView, mode);\n}\n/**\n * Visits a view as part of change detection traversal.\n *\n * - If the view is detached, no additional traversal happens.\n *\n * The view is refreshed if:\n * - If the view is CheckAlways or Dirty and ChangeDetectionMode is `Global`\n * - If the view has the `RefreshTransplantedView` flag\n *\n * The view is not refreshed, but descendants are traversed in `ChangeDetectionMode.Targeted` if the\n * view has a non-zero TRANSPLANTED_VIEWS_TO_REFRESH counter.\n *\n */\nfunction detectChangesInView(lView, mode) {\n  if (!viewAttachedToChangeDetector(lView)) {\n    return;\n  }\n  const tView = lView[TVIEW];\n  if (lView[FLAGS] & (16 /* LViewFlags.CheckAlways */ | 64 /* LViewFlags.Dirty */) && mode === 0 /* ChangeDetectionMode.Global */ || lView[FLAGS] & 1024 /* LViewFlags.RefreshView */ || mode === 2 /* ChangeDetectionMode.BugToForceRefreshAndIgnoreViewFlags */) {\n    refreshView(tView, lView, tView.template, lView[CONTEXT]);\n  } else if (lView[DESCENDANT_VIEWS_TO_REFRESH] > 0) {\n    detectChangesInEmbeddedViews(lView, 1 /* ChangeDetectionMode.Targeted */);\n    const tView = lView[TVIEW];\n    const components = tView.components;\n    if (components !== null) {\n      detectChangesInChildComponents(lView, components, 1 /* ChangeDetectionMode.Targeted */);\n    }\n  }\n}\n/** Refreshes child components in the current view (update mode). */\nfunction detectChangesInChildComponents(hostLView, components, mode) {\n  for (let i = 0; i < components.length; i++) {\n    detectChangesInComponent(hostLView, components[i], mode);\n  }\n}\nclass ViewRef$1 {\n  get rootNodes() {\n    const lView = this._lView;\n    const tView = lView[TVIEW];\n    return collectNativeNodes(tView, lView, tView.firstChild, []);\n  }\n  constructor(\n  /**\n   * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n   *\n   * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n   * component.\n   *\n   * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n   * view.\n   *\n   * @internal\n   */\n  _lView,\n  /**\n   * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n   * requested.\n   *\n   * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n   */\n  _cdRefInjectingView) {\n    this._lView = _lView;\n    this._cdRefInjectingView = _cdRefInjectingView;\n    this._appRef = null;\n    this._attachedToViewContainer = false;\n  }\n  get context() {\n    return this._lView[CONTEXT];\n  }\n  set context(value) {\n    this._lView[CONTEXT] = value;\n  }\n  get destroyed() {\n    return (this._lView[FLAGS] & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */;\n  }\n\n  destroy() {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._attachedToViewContainer) {\n      const parent = this._lView[PARENT];\n      if (isLContainer(parent)) {\n        const viewRefs = parent[VIEW_REFS];\n        const index = viewRefs ? viewRefs.indexOf(this) : -1;\n        if (index > -1) {\n          ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');\n          detachView(parent, index);\n          removeFromArray(viewRefs, index);\n        }\n      }\n      this._attachedToViewContainer = false;\n    }\n    destroyLView(this._lView[TVIEW], this._lView);\n  }\n  onDestroy(callback) {\n    storeLViewOnDestroy(this._lView, callback);\n  }\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'app-root',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck() {\n    markViewDirty(this._cdRefInjectingView || this._lView);\n  }\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach() {\n    this._lView[FLAGS] &= ~128 /* LViewFlags.Attached */;\n  }\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app-root',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach() {\n    this._lView[FLAGS] |= 128 /* LViewFlags.Attached */;\n  }\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach} for more information.\n   */\n  detectChanges() {\n    detectChangesInternal(this._lView[TVIEW], this._lView, this.context);\n  }\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges() {\n    if (ngDevMode) {\n      checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);\n    }\n  }\n  attachToViewContainerRef() {\n    if (this._appRef) {\n      throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached directly to the ApplicationRef!');\n    }\n    this._attachedToViewContainer = true;\n  }\n  detachFromAppRef() {\n    this._appRef = null;\n    renderDetachView(this._lView[TVIEW], this._lView);\n  }\n  attachToAppRef(appRef) {\n    if (this._attachedToViewContainer) {\n      throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached to a ViewContainer!');\n    }\n    this._appRef = appRef;\n  }\n}\n/** @internal */\nclass RootViewRef extends ViewRef$1 {\n  constructor(_view) {\n    super(_view);\n    this._view = _view;\n  }\n  detectChanges() {\n    const lView = this._view;\n    const tView = lView[TVIEW];\n    const context = lView[CONTEXT];\n    detectChangesInternal(tView, lView, context, false);\n  }\n  checkNoChanges() {\n    if (ngDevMode) {\n      const lView = this._view;\n      const tView = lView[TVIEW];\n      const context = lView[CONTEXT];\n      checkNoChangesInternal(tView, lView, context, false);\n    }\n  }\n  get context() {\n    return null;\n  }\n}\nclass ComponentFactoryResolver extends ComponentFactoryResolver$1 {\n  /**\n   * @param ngModule The NgModuleRef to which all resolved factories are bound.\n   */\n  constructor(ngModule) {\n    super();\n    this.ngModule = ngModule;\n  }\n  resolveComponentFactory(component) {\n    ngDevMode && assertComponentType(component);\n    const componentDef = getComponentDef(component);\n    return new ComponentFactory(componentDef, this.ngModule);\n  }\n}\nfunction toRefArray(map) {\n  const array = [];\n  for (let nonMinified in map) {\n    if (map.hasOwnProperty(nonMinified)) {\n      const minified = map[nonMinified];\n      array.push({\n        propName: minified,\n        templateName: nonMinified\n      });\n    }\n  }\n  return array;\n}\nfunction getNamespace(elementName) {\n  const name = elementName.toLowerCase();\n  return name === 'svg' ? SVG_NAMESPACE : name === 'math' ? MATH_ML_NAMESPACE : null;\n}\n/**\n * Injector that looks up a value using a specific injector, before falling back to the module\n * injector. Used primarily when creating components or embedded views dynamically.\n */\nclass ChainedInjector {\n  constructor(injector, parentInjector) {\n    this.injector = injector;\n    this.parentInjector = parentInjector;\n  }\n  get(token, notFoundValue, flags) {\n    flags = convertToBitFlags(flags);\n    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);\n    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n      // Return the value from the root element injector when\n      // - it provides it\n      //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n      // - the module injector should not be checked\n      //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n      return value;\n    }\n    return this.parentInjector.get(token, notFoundValue, flags);\n  }\n}\n/**\n * ComponentFactory interface implementation.\n */\nclass ComponentFactory extends ComponentFactory$1 {\n  get inputs() {\n    const componentDef = this.componentDef;\n    const inputTransforms = componentDef.inputTransforms;\n    const refArray = toRefArray(componentDef.inputs);\n    if (inputTransforms !== null) {\n      for (const input of refArray) {\n        if (inputTransforms.hasOwnProperty(input.propName)) {\n          input.transform = inputTransforms[input.propName];\n        }\n      }\n    }\n    return refArray;\n  }\n  get outputs() {\n    return toRefArray(this.componentDef.outputs);\n  }\n  /**\n   * @param componentDef The component definition.\n   * @param ngModule The NgModuleRef to which the factory is bound.\n   */\n  constructor(componentDef, ngModule) {\n    super();\n    this.componentDef = componentDef;\n    this.ngModule = ngModule;\n    this.componentType = componentDef.type;\n    this.selector = stringifyCSSSelectorList(componentDef.selectors);\n    this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];\n    this.isBoundToModule = !!ngModule;\n  }\n  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {\n    environmentInjector = environmentInjector || this.ngModule;\n    let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;\n    if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {\n      realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;\n    }\n    const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;\n    const rendererFactory = rootViewInjector.get(RendererFactory2, null);\n    if (rendererFactory === null) {\n      throw new RuntimeError(407 /* RuntimeErrorCode.RENDERER_NOT_FOUND */, ngDevMode && 'Angular was not able to inject a renderer (RendererFactory2). ' + 'Likely this is due to a broken DI hierarchy. ' + 'Make sure that any injector used to create this component has a correct parent.');\n    }\n    const sanitizer = rootViewInjector.get(Sanitizer, null);\n    const effectManager = rootViewInjector.get(EffectManager, null);\n    const environment = {\n      rendererFactory,\n      sanitizer,\n      effectManager\n    };\n    const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);\n    // Determine a tag name used for creating host elements when this component is created\n    // dynamically. Default to 'div' if this component did not specify any tag name in its selector.\n    const elementName = this.componentDef.selectors[0][0] || 'div';\n    const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation, rootViewInjector) : createElementNode(hostRenderer, elementName, getNamespace(elementName));\n    // Signal components use the granular \"RefreshView\"  for change detection\n    const signalFlags = 4096 /* LViewFlags.SignalView */ | 512 /* LViewFlags.IsRoot */;\n    // Non-signal components use the traditional \"CheckAlways or OnPush/Dirty\" change detection\n    const nonSignalFlags = this.componentDef.onPush ? 64 /* LViewFlags.Dirty */ | 512 /* LViewFlags.IsRoot */ : 16 /* LViewFlags.CheckAlways */ | 512 /* LViewFlags.IsRoot */;\n    const rootFlags = this.componentDef.signals ? signalFlags : nonSignalFlags;\n    // Create the root view. Uses empty TView and ContentTemplate.\n    const rootTView = createTView(0 /* TViewType.Root */, null, null, 1, 0, null, null, null, null, null, null);\n    const rootLView = createLView(null, rootTView, null, rootFlags, null, null, environment, hostRenderer, rootViewInjector, null, null);\n    // rootView is the parent when bootstrapping\n    // TODO(misko): it looks like we are entering view here but we don't really need to as\n    // `renderView` does that. However as the code is written it is needed because\n    // `createRootComponentView` and `createRootComponent` both read global state. Fixing those\n    // issues would allow us to drop this.\n    enterView(rootLView);\n    let component;\n    let tElementNode;\n    try {\n      const rootComponentDef = this.componentDef;\n      let rootDirectives;\n      let hostDirectiveDefs = null;\n      if (rootComponentDef.findHostDirectiveDefs) {\n        rootDirectives = [];\n        hostDirectiveDefs = new Map();\n        rootComponentDef.findHostDirectiveDefs(rootComponentDef, rootDirectives, hostDirectiveDefs);\n        rootDirectives.push(rootComponentDef);\n      } else {\n        rootDirectives = [rootComponentDef];\n      }\n      const hostTNode = createRootComponentTNode(rootLView, hostRNode);\n      const componentView = createRootComponentView(hostTNode, hostRNode, rootComponentDef, rootDirectives, rootLView, environment, hostRenderer);\n      tElementNode = getTNode(rootTView, HEADER_OFFSET);\n      // TODO(crisbeto): in practice `hostRNode` should always be defined, but there are some tests\n      // where the renderer is mocked out and `undefined` is returned. We should update the tests so\n      // that this check can be removed.\n      if (hostRNode) {\n        setRootNodeAttributes(hostRenderer, rootComponentDef, hostRNode, rootSelectorOrNode);\n      }\n      if (projectableNodes !== undefined) {\n        projectNodes(tElementNode, this.ngContentSelectors, projectableNodes);\n      }\n      // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\n      // executed here?\n      // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\n      component = createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, [LifecycleHooksFeature]);\n      renderView(rootTView, rootLView, null);\n    } finally {\n      leaveView();\n    }\n    return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);\n  }\n}\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nclass ComponentRef extends ComponentRef$1 {\n  constructor(componentType, instance, location, _rootLView, _tNode) {\n    super();\n    this.location = location;\n    this._rootLView = _rootLView;\n    this._tNode = _tNode;\n    this.previousInputValues = null;\n    this.instance = instance;\n    this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);\n    this.componentType = componentType;\n  }\n  setInput(name, value) {\n    const inputData = this._tNode.inputs;\n    let dataValue;\n    if (inputData !== null && (dataValue = inputData[name])) {\n      this.previousInputValues ??= new Map();\n      // Do not set the input if it is the same as the last value\n      // This behavior matches `bindingUpdated` when binding inputs in templates.\n      if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {\n        return;\n      }\n      const lView = this._rootLView;\n      setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);\n      this.previousInputValues.set(name, value);\n      const childComponentLView = getComponentLViewByIndex(this._tNode.index, lView);\n      markViewDirty(childComponentLView);\n    } else {\n      if (ngDevMode) {\n        const cmpNameForError = stringifyForError(this.componentType);\n        let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;\n        message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;\n        reportUnknownPropertyError(message);\n      }\n    }\n  }\n  get injector() {\n    return new NodeInjector(this._tNode, this._rootLView);\n  }\n  destroy() {\n    this.hostView.destroy();\n  }\n  onDestroy(callback) {\n    this.hostView.onDestroy(callback);\n  }\n}\n// TODO: A hack to not pull in the NullInjector from @angular/core.\nconst NULL_INJECTOR = {\n  get: (token, notFoundValue) => {\n    throwProviderNotFoundError(token, 'NullInjector');\n  }\n};\n/** Creates a TNode that can be used to instantiate a root component. */\nfunction createRootComponentTNode(lView, rNode) {\n  const tView = lView[TVIEW];\n  const index = HEADER_OFFSET;\n  ngDevMode && assertIndexInRange(lView, index);\n  lView[index] = rNode;\n  // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n  // the same time we want to communicate the debug `TNode` that this is a special `TNode`\n  // representing a host element.\n  return getOrCreateTNode(tView, index, 2 /* TNodeType.Element */, '#host', null);\n}\n/**\n * Creates the root component view and the root component node.\n *\n * @param hostRNode Render host element.\n * @param rootComponentDef ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param rendererFactory Factory to be used for creating child renderers.\n * @param hostRenderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nfunction createRootComponentView(tNode, hostRNode, rootComponentDef, rootDirectives, rootView, environment, hostRenderer) {\n  const tView = rootView[TVIEW];\n  applyRootComponentStyling(rootDirectives, tNode, hostRNode, hostRenderer);\n  // Hydration info is on the host element and needs to be retreived\n  // and passed to the component LView.\n  let hydrationInfo = null;\n  if (hostRNode !== null) {\n    hydrationInfo = retrieveHydrationInfo(hostRNode, rootView[INJECTOR$1]);\n  }\n  const viewRenderer = environment.rendererFactory.createRenderer(hostRNode, rootComponentDef);\n  let lViewFlags = 16 /* LViewFlags.CheckAlways */;\n  if (rootComponentDef.signals) {\n    lViewFlags = 4096 /* LViewFlags.SignalView */;\n  } else if (rootComponentDef.onPush) {\n    lViewFlags = 64 /* LViewFlags.Dirty */;\n  }\n\n  const componentView = createLView(rootView, getOrCreateComponentTView(rootComponentDef), null, lViewFlags, rootView[tNode.index], tNode, environment, viewRenderer, null, null, hydrationInfo);\n  if (tView.firstCreatePass) {\n    markAsComponentHost(tView, tNode, rootDirectives.length - 1);\n  }\n  addToViewTree(rootView, componentView);\n  // Store component view at node index, with node as the HOST\n  return rootView[tNode.index] = componentView;\n}\n/** Sets up the styling information on a root component. */\nfunction applyRootComponentStyling(rootDirectives, tNode, rNode, hostRenderer) {\n  for (const def of rootDirectives) {\n    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n  }\n  if (tNode.mergedAttrs !== null) {\n    computeStaticStyling(tNode, tNode.mergedAttrs, true);\n    if (rNode !== null) {\n      setupStaticAttributes(hostRenderer, rNode, tNode);\n    }\n  }\n}\n/**\n * Creates a root component and sets it up with features and host bindings.Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nfunction createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, hostFeatures) {\n  const rootTNode = getCurrentTNode();\n  ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');\n  const tView = rootLView[TVIEW];\n  const native = getNativeByTNode(rootTNode, rootLView);\n  initializeDirectives(tView, rootLView, rootTNode, rootDirectives, null, hostDirectiveDefs);\n  for (let i = 0; i < rootDirectives.length; i++) {\n    const directiveIndex = rootTNode.directiveStart + i;\n    const directiveInstance = getNodeInjectable(rootLView, tView, directiveIndex, rootTNode);\n    attachPatchData(directiveInstance, rootLView);\n  }\n  invokeDirectivesHostBindings(tView, rootLView, rootTNode);\n  if (native) {